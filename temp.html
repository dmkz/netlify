<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Анализ ссылок на бои с фильтрацией</title>
  <style>
    /* Стили для основной формы и фильтра */
    textarea {
      font-family: monospace;
    }
    #statusDisplay {
      font-weight: bold;
      margin: 10px 0;
    }
    /* Стили для блока опций фильтрации */
    .filter-container {
      padding: 5px;
      border: 2px solid #8b4513;
      background: #f0e6d2;
      margin-bottom: 10px;
    }
    .filter-container div {
      margin-bottom: 4px;
    }
  </style>
</head>
<body>
  <textarea id="inputText" rows="10" cols="80" placeholder="Вставьте сюда текст с ссылками на бои..."></textarea>
  <br>
  <button id="analyzeButton">Анализировать ссылки</button>
  <div id="statusDisplay"></div>
  
  <!-- Контейнер для чекбоксов фильтрации -->
  <div id="filterOptions" class="filter-container"></div>
  
  <textarea id="outputArea" rows="10" cols="80" placeholder="Здесь появится модифицированный текст..."></textarea>

  <script>
    // -----------------------------------------------------------
    // Основая логика анализа ссылок (без фильтрации)
    // -----------------------------------------------------------
    // Функция для извлечения ссылок вида https://www.heroeswm.ru/war.php?warid=...
    function extractBattleLinks(text) {
      let regex = /https:\/\/www\.heroeswm\.ru\/war\.php\?warid=\d+/g;
      let links = text.match(regex) || [];
      return [...new Set(links)];
    }

    // -----------------------------------------------------------
    // Фильтрация – настройки и функции преобразования
    // -----------------------------------------------------------
    const defaultFilterOptions = {
      shortenMarkers: true,
      showWinningSideName: true,
      showLosingSideName: true,
      showWinningHP: true,
      showLosingHP: true,
      showWinningPercent: true,
      showLosingPercent: true,
      showWinningFaction: true,
      showLosingFaction: true,
      showWinningHeroInfo: true,
      showLosingHeroInfo: true,
      showWinningHeroNickname: true,
      showLosingHeroNickname: true,
      showWinningHeroLevel: true,
      showLosingHeroLevel: true,
      showWinningHeroParams: true,
      showLosingHeroParams: true,
      shortenWinningHeroParams: true,
      shortenLosingHeroParams: true,
      showWinningArmy: true,
      showLosingArmy: true,
      showWinningBonuses: true,
      showLosingBonuses: true
    };

    function loadFilterOptions() {
      let stored = localStorage.getItem("battleFilterOptions");
      if (stored) {
        try {
          return JSON.parse(stored);
        } catch(e) {
          return Object.assign({}, defaultFilterOptions);
        }
      }
      return Object.assign({}, defaultFilterOptions);
    }
    function saveFilterOptions(options) {
      localStorage.setItem("battleFilterOptions", JSON.stringify(options));
    }
    let filterOptions = loadFilterOptions();

    // Глобальная переменная для хранения исходного (неотфильтрованного) вывода
    let originalOutput = "";

    // Функция для создания чекбокса с меткой
    function createCheckbox(labelText, optionName, checked) {
      let container = document.createElement("div");
      let checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = checked;
      checkbox.setAttribute("data-option", optionName);
      let label = document.createElement("label");
      label.textContent = labelText;
      label.style.marginLeft = "4px";
      container.appendChild(checkbox);
      container.appendChild(label);
      return { container, checkbox, label };
    }

    // Создание интерфейса для опций фильтрации в контейнере #filterOptions
    function createFilterOptionsUI() {
      let optionsContainer = document.getElementById("filterOptions");
      optionsContainer.innerHTML = "<strong>Фильтр результатов:</strong>";

      // Общая опция
      let common = createCheckbox("Сокращать маркеры (win/lose)", "shortenMarkers", filterOptions.shortenMarkers);
      optionsContainer.appendChild(common.container);

      // Опции для победителей
      let winnersTitle = document.createElement("div");
      winnersTitle.textContent = "Победители";
      winnersTitle.style.fontWeight = "bold";
      winnersTitle.style.marginTop = "8px";
      optionsContainer.appendChild(winnersTitle);
      optionsContainer.appendChild(createCheckbox("Название стороны", "showWinningSideName", filterOptions.showWinningSideName).container);
      optionsContainer.appendChild(createCheckbox("Суммарное ХП", "showWinningHP", filterOptions.showWinningHP).container);
      optionsContainer.appendChild(createCheckbox("% выживших", "showWinningPercent", filterOptions.showWinningPercent).container);
      optionsContainer.appendChild(createCheckbox("Фракция", "showWinningFaction", filterOptions.showWinningFaction).container);
      optionsContainer.appendChild(createCheckbox("Информация о героях", "showWinningHeroInfo", filterOptions.showWinningHeroInfo).container);
      optionsContainer.appendChild(createCheckbox("Никнейм героев", "showWinningHeroNickname", filterOptions.showWinningHeroNickname).container);
      optionsContainer.appendChild(createCheckbox("Уровень героев", "showWinningHeroLevel", filterOptions.showWinningHeroLevel).container);
      optionsContainer.appendChild(createCheckbox("Параметры героев", "showWinningHeroParams", filterOptions.showWinningHeroParams).container);
      optionsContainer.appendChild(createCheckbox("Сокращать параметры героев", "shortenWinningHeroParams", filterOptions.shortenWinningHeroParams).container);
      optionsContainer.appendChild(createCheckbox("Армия", "showWinningArmy", filterOptions.showWinningArmy).container);
      optionsContainer.appendChild(createCheckbox("Бонусы", "showWinningBonuses", filterOptions.showWinningBonuses).container);

      // Опции для проигравших
      let losersTitle = document.createElement("div");
      losersTitle.textContent = "Проигравшие";
      losersTitle.style.fontWeight = "bold";
      losersTitle.style.marginTop = "8px";
      optionsContainer.appendChild(losersTitle);
      optionsContainer.appendChild(createCheckbox("Название стороны", "showLosingSideName", filterOptions.showLosingSideName).container);
      optionsContainer.appendChild(createCheckbox("Суммарное ХП", "showLosingHP", filterOptions.showLosingHP).container);
      optionsContainer.appendChild(createCheckbox("% выживших", "showLosingPercent", filterOptions.showLosingPercent).container);
      optionsContainer.appendChild(createCheckbox("Фракция", "showLosingFaction", filterOptions.showLosingFaction).container);
      optionsContainer.appendChild(createCheckbox("Информация о героях", "showLosingHeroInfo", filterOptions.showLosingHeroInfo).container);
      optionsContainer.appendChild(createCheckbox("Никнейм героев", "showLosingHeroNickname", filterOptions.showLosingHeroNickname).container);
      optionsContainer.appendChild(createCheckbox("Уровень героев", "showLosingHeroLevel", filterOptions.showLosingHeroLevel).container);
      optionsContainer.appendChild(createCheckbox("Параметры героев", "showLosingHeroParams", filterOptions.showLosingHeroParams).container);
      optionsContainer.appendChild(createCheckbox("Сокращать параметры героев", "shortenLosingHeroParams", filterOptions.shortenLosingHeroParams).container);
      optionsContainer.appendChild(createCheckbox("Армия", "showLosingArmy", filterOptions.showLosingArmy).container);
      optionsContainer.appendChild(createCheckbox("Бонусы", "showLosingBonuses", filterOptions.showLosingBonuses).container);

      // При изменении любого чекбокса обновляем опции и перерисовываем вывод
      optionsContainer.querySelectorAll("input[type=checkbox]").forEach(checkbox => {
        checkbox.addEventListener("change", function() {
          let name = this.getAttribute("data-option");
          filterOptions[name] = this.checked;
          saveFilterOptions(filterOptions);
          updateFilteredOutput();
        });
      });
    }

    // Функция для сокращения параметров героя (например, "Нападение:" → "Н:")
    function shortenHeroParams(paramsBlock) {
      const mapping = {
        "Нападение:": "Н:",
        "Защита:": "З:",
        "Сила магии:": "СМ:",
        "Знания:": "ЗН:",
        "Удача:": "Уд:",
        "Боевой Дух:": "БД:",
        "Уровень:": "У:"
      };
      for (let key in mapping) {
        let regex = new RegExp(key, "gi");
        paramsBlock = paramsBlock.replace(regex, mapping[key]);
      }
      return paramsBlock.replace(/\s+/g, "");
    }

    // Функция для преобразования информации о герое
    function transformHeroBlock(heroBlock, isWinner, opts) {
      if ((isWinner && !opts.showWinningHeroInfo) || (!isWinner && !opts.showLosingHeroInfo)) {
        return "";
      }
      let firstBracket = heroBlock.indexOf("[");
      let nickname = "";
      let blocks = [];
      if (firstBracket !== -1) {
        nickname = heroBlock.substring(0, firstBracket).trim();
        let regex = /\[([^\]]+)\]/g;
        let m;
        while ((m = regex.exec(heroBlock)) !== null) {
          blocks.push(m[1]);
        }
      } else {
        nickname = heroBlock.trim();
      }
      let levelBlock = "";
      let paramsBlock = "";
      if (blocks.length > 0) {
        if (/Уровень:|^У:/i.test(blocks[0])) {
          levelBlock = blocks[0];
          if (blocks.length > 1) {
            paramsBlock = blocks.slice(1).join("][");
          }
        } else {
          paramsBlock = blocks.join("][");
        }
      }
      if ((isWinner && !opts.showWinningHeroNickname) || (!isWinner && !opts.showLosingHeroNickname)) {
        nickname = "";
      }
      if (!((isWinner && opts.showWinningHeroLevel) || (!isWinner && opts.showLosingHeroLevel))) {
        levelBlock = "";
      } else if (levelBlock) {
        if ((isWinner && opts.shortenWinningHeroParams) || (!isWinner && opts.shortenLosingHeroParams)) {
          levelBlock = levelBlock.replace(/Уровень:/gi, "У:").replace(/\s+/g, "");
        }
        levelBlock = "[" + levelBlock + "]";
      }
      if (!((isWinner && opts.showWinningHeroParams) || (!isWinner && opts.showLosingHeroParams))) {
        paramsBlock = "";
      } else if (paramsBlock) {
        let tmp = "[" + paramsBlock + "]";
        if ((isWinner && opts.shortenWinningHeroParams) || (!isWinner && opts.shortenLosingHeroParams)) {
          tmp = shortenHeroParams(tmp);
        }
        paramsBlock = tmp;
      }
      return (nickname + levelBlock + paramsBlock).trim();
    }

    // Функция преобразования одной строки результата (предполагается, что строка разбита на блоки в квадратных скобках)
    function transformLine(line, opts) {
      let trimmed = line.trim();
      if (!trimmed) return "";
      if (!trimmed.startsWith("[")) return line;
      let inner = trimmed.substring(1, trimmed.length - 1);
      let blocks = inner.split("] [");
      let marker = blocks[0];
      let isWinner = (marker.toLowerCase().includes("win") || marker.indexOf("+") !== -1);
      let isLoser = (marker.toLowerCase().includes("lose") || marker.indexOf("-") !== -1);
      // Блок 0 – маркер
      if (isWinner || isLoser) {
        if (opts.shortenMarkers) {
          blocks[0] = isWinner ? "+" : "-";
        }
      }
      // Блок 1 – название стороны
      if ((isWinner && !opts.showWinningSideName) || (!isWinner && !opts.showLosingSideName)) {
        blocks[1] = "";
      }
      // Блок 2 – суммарное ХП
      if ((isWinner && !opts.showWinningHP) || (!isWinner && !opts.showLosingHP)) {
        blocks[2] = "";
      }
      // Блок 3 – % выживших
      if ((isWinner && !opts.showWinningPercent) || (!isWinner && !opts.showLosingPercent)) {
        blocks[3] = "";
      }
      // Блок 4 – фракция
      if ((isWinner && !opts.showWinningFaction) || (!isWinner && !opts.showLosingFaction)) {
        blocks[4] = "";
      }
      // Блок 5 – информация о героях
      if (blocks.length > 5) {
        blocks[5] = transformHeroBlock(blocks[5], isWinner, opts);
      }
      // Блок 6 – армия
      if (blocks.length > 6) {
        if ((isWinner && !opts.showWinningArmy) || (!isWinner && !opts.showLosingArmy)) {
          blocks[6] = "";
        }
      }
      // Блок 7 – бонусы
      if (blocks.length > 7) {
        if ((isWinner && !opts.showWinningBonuses) || (!isWinner && !opts.showLosingBonuses)) {
          blocks[7] = "";
        }
      }
      return blocks.filter(b => b !== "").map(b => "[" + b + "]").join(" ");
    }

    // Функция для преобразования многострочного текста
    function transformTokensText(inputText, opts) {
      let lines = inputText.split("\n");
      let transformed = lines.map(line => transformLine(line, opts));
      return transformed.join("\n");
    }

    // Обновление вывода в textarea согласно текущим настройкам
    function updateFilteredOutput() {
      if (!originalOutput) return;
      let newText = transformTokensText(originalOutput, filterOptions);
      document.getElementById("outputArea").value = newText;
    }

    // Создаем UI опций фильтрации при загрузке страницы
    createFilterOptionsUI();

    // -----------------------------------------------------------
    // Основной обработчик анализа ссылок
    // -----------------------------------------------------------
    document.getElementById("analyzeButton").addEventListener("click", async () => {
      let inputText = document.getElementById("inputText").value;
      let links = extractBattleLinks(inputText);
      let statusDisplay = document.getElementById("statusDisplay");
      
      if (links.length === 0) {
        statusDisplay.textContent = "Ссылки не найдены.";
        return;
      }
      
      statusDisplay.textContent = `Найдено ${links.length} ссылок. Отправляем бои на анализ...`;
      
      // Функция вызова API анализа (предполагается функция на сервере)
      async function callAnalyze(linksArray) {
        let response = await fetch("/.netlify/functions/analyzeBattles", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ links: linksArray })
        });
        return response.json();
      }
      
      let remainingLinks = links;
      let finalResults = [];
      let retryRound = 1;
      let secondsElapsed = 0;
      
      let intervalId = setInterval(() => {
        secondsElapsed++;
        statusDisplay.textContent = `Ждём ${secondsElapsed} сек... (Попытка ${retryRound}. Осталось анализировать ${remainingLinks.length} ссылок)`;
      }, 1000);
      
      while (remainingLinks.length > 0) {
        statusDisplay.textContent += `; Попытка ${retryRound}, отправляем ${remainingLinks.length} ссылок...`;
        let result = await callAnalyze(remainingLinks);
        let errorLinks = [];
        result.results.forEach(r => {
          if (r.status === "success") {
            finalResults.push(r);
          } else {
            errorLinks.push(r.link);
          }
        });
        remainingLinks = errorLinks;
        if (remainingLinks.length > 0) {
          statusDisplay.textContent += `; Повторная отправка для ${remainingLinks.length} ссылок.`;
        }
        retryRound++;
      }
      
      clearInterval(intervalId);
      statusDisplay.textContent = `Анализ завершён. Всего успешно: ${finalResults.length}.`;
      
      // Формируем оригинальный вывод: для каждой ссылки записываем строку вида "ссылка: результат анализа"
      originalOutput = "";
      finalResults.forEach(r => {
        let analysisStr = r.result ? r.result : "Ошибка анализа";
        originalOutput += `${r.link}: ${analysisStr}\n`;
      });
      
      // Обновляем отображение с учётом выбранных фильтров
      updateFilteredOutput();
    });
  </script>
</body>
</html>
