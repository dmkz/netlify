<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="windows-1251">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Администрирование тех. клана</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .container { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; }
    .field { flex: 1; min-width: 300px; }
    textarea { width: 100%; height: 200px; font-family: monospace; }
    button { padding: 10px 20px; font-size: 16px; }
    .collapsible { margin-bottom: 10px; border: 1px solid #ccc; }
    .collapsible-header { background-color: #f0f0f0; padding: 5px; cursor: pointer; }
    .collapsible-list { margin: 0; padding: 5px; }
    table { width: 100%; border-collapse: collapse; }
    td { border: 1px solid #ccc; padding: 5px; text-align: left; }
    td a { text-decoration: none; color: blue; }
    td a:hover { text-decoration: underline; }
    .remove-button { color: red; border: none; background: none; cursor: pointer; }
    #statusMessage { font-size: 16px; margin-bottom: 10px; }
    /* Дополнительное поле для сырых данных */
    #rawData {
      width: 100%;
      height: 200px;
      font-family: monospace;
      margin-top: 15px;
      border: 1px solid #ccc;
      padding: 5px;
      white-space: pre-wrap;
      overflow-y: scroll;
    }
    /* Контейнер для отладки боевых кланов */
    #debugOutput {
      margin-top: 20px;
    }
    #debugOutput textarea {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Администрирование тех. клана</h1>
  <div class="container">
    <div class="field">
      <h3>Технические кланы<br/>(ID, по одному в строке)</h3>
      <textarea id="techClans">9098</textarea>
    </div>
    <div class="field">
      <h3>Боевые кланы<br/>(ID, по одному в строке)</h3>
      <textarea id="battleClans">1209
7490
7705
9595
5722</textarea>
    </div>
    <div class="field">
      <h3>Особенные игроки<br/>(ID, по одному в строке)</h3>
      <textarea id="excludePlayers"></textarea>
    </div>
  </div>
  <!-- Элемент для статуса запроса -->
  <div id="statusMessage"></div>
  <button id="processBtn">Обработать</button>
  <h2>Результаты:</h2>
  <div id="results"></div>
  <!-- Дополнительное поле для сырых данных (JSON) -->
  <h2>Сырые данные от сервера (для дебага):</h2>
  <textarea id="rawData" readonly></textarea>
  <!-- Контейнер для отладочного вывода боевых кланов -->
  <h2>Отладка боевых кланов:</h2>
  <div id="debugOutput"></div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      console.log('clan2.html loaded');

      // Функции для работы с collapsible-блоками (без изменений)
      function findClosestGrouped(el) {
        while (el) {
          if (el.nodeType === Node.ELEMENT_NODE && el.classList.contains('grouped')) {
            return el;
          }
          el = el.parentNode;
        }
        return null;
      }
      function updateGroupedHeader(groupedContainer) {
        const contentDiv = groupedContainer.children[1];
        let total = 0;
        if (contentDiv) {
          for (let i = 0; i < contentDiv.children.length; i++) {
            const inner = contentDiv.children[i];
            const innerHeader = inner.querySelector('.collapsible-header');
            if (innerHeader) {
              const match = innerHeader.textContent.match(/\((\d+)\)/);
              if (match) { total += parseInt(match[1], 10); }
            }
          }
        }
        const outerHeader = groupedContainer.firstElementChild;
        if (outerHeader) {
          const baseText = outerHeader.dataset.basetitle || outerHeader.textContent.split('(')[0].trim();
          outerHeader.dataset.basetitle = baseText;
          outerHeader.textContent = `${baseText} (${total})`;
        }
      }
      function createPlayerTable(items, groupType) {
        const table = document.createElement('table');
        items.forEach(item => {
          const tr = document.createElement('tr');
          const tdId = document.createElement('td');
          tdId.textContent = item.id;
          tr.appendChild(tdId);
          const tdName = document.createElement('td');
          const aName = document.createElement('a');
          aName.href = `https://www.heroeswm.ru/pl_info.php?id=${item.id}`;
          aName.target = '_blank';
          aName.textContent = item.name;
          tdName.appendChild(aName);
          tr.appendChild(tdName);
          const tdButton = document.createElement('td');
          const btn = document.createElement('button');
          btn.textContent = '✖';
          btn.classList.add('remove-button');
          btn.addEventListener('click', () => {
            const parentTable = tr.parentElement;
            tr.remove();
            const collapsible = parentTable.closest('.collapsible');
            if (collapsible) {
              const header = collapsible.querySelector('.collapsible-header');
              const newCount = parentTable.querySelectorAll('tr').length;
              header.textContent = header.textContent.replace(/\(\d+\)/, `(${newCount})`);
            }
            const outerGrouped = tr.closest('.grouped');
            if (outerGrouped) { updateGroupedHeader(outerGrouped); }
            const excludeTextarea = document.getElementById('excludePlayers');
            let currentExcludes = excludeTextarea.value.split('\n').map(s => s.trim()).filter(Boolean);
            if (!currentExcludes.includes(item.id)) {
              currentExcludes.push(item.id);
              excludeTextarea.value = currentExcludes.join('\n');
              localStorage.setItem('excludePlayers', excludeTextarea.value);
            }
          });
          tdButton.appendChild(btn);
          tr.appendChild(tdButton);
          table.appendChild(tr);
        });
        return table;
      }
      function createCollapsible(title, items, groupType) {
        const container = document.createElement('div');
        container.classList.add('collapsible');
        const header = document.createElement('div');
        header.classList.add('collapsible-header');
        header.textContent = title + ' (' + items.length + ')';
        container.appendChild(header);
        const content = document.createElement('div');
        content.style.display = 'none';
        const table = createPlayerTable(items, groupType);
        content.appendChild(table);
        container.appendChild(content);
        header.addEventListener('click', () => {
          content.style.display = content.style.display === 'none' ? 'block' : 'none';
        });
        return container;
      }
      function createGroupedCollapsible(groupedData, title, groupType) {
        const container = document.createElement('div');
        container.classList.add('collapsible', 'grouped');
        let totalCount = 0;
        Object.values(groupedData).forEach(group => {
          totalCount += group.players.length;
        });
        const header = document.createElement('div');
        header.classList.add('collapsible-header');
        header.dataset.basetitle = title;
        header.textContent = title + ' (' + totalCount + ')';
        container.appendChild(header);
        const content = document.createElement('div');
        content.style.display = 'none';
        Object.keys(groupedData).forEach(key => {
          const group = groupedData[key];
          const headerText = group.clanName;
          const groupCollapsible = createCollapsible(headerText, group.players, groupType);
          content.appendChild(groupCollapsible);
        });
        container.appendChild(content);
        header.addEventListener('click', () => {
          content.style.display = content.style.display === 'none' ? 'block' : 'none';
        });
        return container;
      }

      // Функция для парсинга HTML-страницы боевого клана (упрощённая версия)
      function parseBattleClan(html, battleClanId) {
        // Найти заголовок <h1> и извлечь его содержимое
        let h1Start = html.indexOf("<h1");
        if (h1Start === -1) return { clanName: "", members: [] };
        let h1End = html.indexOf("</h1>", h1Start);
        if (h1End === -1) h1End = html.length;
        let h1Content = html.substring(h1Start, h1End);
        // Извлекаем название клана из тега <b>…</b>
        let bStart = h1Content.indexOf("<b>");
        let bEnd = h1Content.indexOf("</b>", bStart);
        let clanName = "";
        if (bStart !== -1 && bEnd !== -1) {
          clanName = h1Content.substring(bStart + 3, bEnd).trim();
        }
        // Находим последнее вхождение "<table" и извлекаем содержимое таблицы
        let tableIndex = html.lastIndexOf("<table");
        if (tableIndex === -1) return { clanName, members: [] };
        let tableEnd = html.indexOf("</table>", tableIndex);
        if (tableEnd === -1) tableEnd = html.length;
        let tableContent = html.substring(tableIndex, tableEnd);
        let members = [];
        let pos = 0;
        // Перебираем строки таблицы
        while (true) {
          let trStart = tableContent.indexOf("<tr", pos);
          if (trStart === -1) break;
          let trEnd = tableContent.indexOf("</tr>", trStart);
          if (trEnd === -1) break;
          let trContent = tableContent.substring(trStart, trEnd);
          // Ищем ссылку на страницу игрока
          let anchorIndex = trContent.indexOf("pl_info.php?id=");
          if (anchorIndex !== -1) {
            let idStart = anchorIndex + "pl_info.php?id=".length;
            // Ищем завершающую кавычку (одинарную или двойную)
            let idEnd = trContent.indexOf("'", idStart);
            if (idEnd === -1) { idEnd = trContent.indexOf("\"", idStart); }
            if (idEnd !== -1) {
              let playerId = trContent.substring(idStart, idEnd).trim();
              // Ищем текст между символом ">" и следующим "<"
              let nameStart = trContent.indexOf(">", idEnd);
              if (nameStart !== -1) {
                nameStart++;
                let nameEnd = trContent.indexOf("<", nameStart);
                if (nameEnd !== -1) {
                  let playerName = trContent.substring(nameStart, nameEnd).trim();
                  members.push({
                    id: playerId,
                    name: playerName,
                    classification: 'member',
                    joinedBattleClanId: battleClanId,
                    joinedBattleClanName: clanName
                  });
                }
              }
            }
          }
          pos = trEnd + 5; // переходим за "</tr>"
        }
        // Формирование отладочного текста
        let debugText = `Клан: ${clanName}\nУчастников: ${members.length}\n`;
        members.forEach((member, index) => {
          debugText += `Игрок ${index + 1}: ${member.name} (ID: ${member.id})\n`;
        });
        // Создаём текстовое поле для отладки и выводим туда информацию
        let debugContainer = document.getElementById("debugOutput");
        if (!debugContainer) {
          debugContainer = document.createElement("div");
          debugContainer.id = "debugOutput";
          document.body.appendChild(debugContainer);
        }
        let debugTextarea = document.createElement("textarea");
        debugTextarea.readOnly = true;
        debugTextarea.style.width = "100%";
        debugTextarea.style.height = "200px";
        debugTextarea.value = debugText;
        debugContainer.appendChild(debugTextarea);
        return { clanName, members };
      }

      // Функция для парсинга технического клана (оставляем прежнюю реализацию с использованием DOMParser)
      function parseTechClan(html, battleIdsSet) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const h1 = doc.querySelector('h1');
        const clanName = h1 ? h1.textContent.trim() : '';
        const tables = doc.querySelectorAll('table');
        const lastTable = tables[tables.length - 1];
        let members = [];
        if (lastTable) {
          const rows = lastTable.querySelectorAll('tr');
          rows.forEach(tr => {
            const links = tr.querySelectorAll('a[href*="pl_info.php?id="]');
            if (links.length === 0) return;
            const aPlayer = links[links.length - 1];
            const href = aPlayer.getAttribute('href');
            const idMatch = href.match(/pl_info\.php\?id=(\d+)/);
            if (!idMatch) return;
            const playerId = idMatch[1];
            const playerName = aPlayer.textContent.trim();
            let classification = 'clanless';
            let joinedBattleClanId = null;
            let joinedBattleClanName = null;
            const rowHtml = tr.innerHTML;
            const playerLinkHtml = aPlayer.outerHTML;
            const index = rowHtml.indexOf(playerLinkHtml);
            if (index !== -1) {
              const beforePlayer = rowHtml.substring(0, index);
              const battleMatch = beforePlayer.match(/<a\s+href=["']clan_info\.php\?id=(\d+)["'][^>]*title=['"]([^'"]+)['"]/);
              if (battleMatch) {
                joinedBattleClanId = battleMatch[1];
                joinedBattleClanName = battleMatch[2];
                if (battleIdsSet.has(joinedBattleClanId)) {
                  classification = "member";
                } else {
                  classification = "enemy";
                }
              }
            }
            members.push({ id: playerId, name: playerName, classification, joinedBattleClanId, joinedBattleClanName });
          });
        }
        return { clanName, members };
      }

      // Функция renderResults обрабатывает данные с сервера
      function renderResults(data) {
        // Парсим боевые кланы с использованием новой функции parseBattleClan
        const parsedBattleClans = data.battleClans.map(bc => {
          const parsed = parseBattleClan(bc.html, bc.clanId);
          return { clanId: bc.clanId, clanName: parsed.clanName, members: parsed.members };
        });
        // Формируем карту участников боевых кланов
        const battleMembersMap = new Map();
        parsedBattleClans.forEach(bc => {
          bc.members.forEach(member => {
            battleMembersMap.set(member.id, { clanId: bc.clanId, clanName: bc.clanName });
          });
        });
        // Создаём множество ID боевых кланов для технических кланов
        const battleIdsSet = new Set(data.battleClans.map(b => b.clanId));
        // Парсим технические кланы (с использованием прежней функции)
        const parsedTechClans = data.techClans.map(tc => {
          const parsed = parseTechClan(tc.html, battleIdsSet);
          return { clanId: tc.clanId, clanName: parsed.clanName, members: parsed.members };
        });
        // Формируем итоговый результат для каждого технического клана
        const results = parsedTechClans.map(techClan => {
          const techMemberIds = new Set(techClan.members.map(m => m.id));
          const inviteGroups = {};
          battleMembersMap.forEach((info, memberId) => {
            if (!techMemberIds.has(memberId)) {
              if (!inviteGroups[info.clanId]) {
                inviteGroups[info.clanId] = { clanName: info.clanName, players: [] };
              }
              const battleClan = parsedBattleClans.find(bc => bc.clanId === info.clanId);
              if (battleClan) {
                const memberDetail = battleClan.members.find(m => m.id === memberId);
                if (memberDetail) {
                  inviteGroups[info.clanId].players.push(memberDetail);
                }
              }
            }
          });
          const enemyGroups = {};
          techClan.members.forEach(member => {
            if (member.classification === 'enemy') {
              if (member.joinedBattleClanId) {
                if (!enemyGroups[member.joinedBattleClanId]) {
                  enemyGroups[member.joinedBattleClanId] = { clanName: member.joinedBattleClanName || 'Неизвестный', players: [] };
                }
                enemyGroups[member.joinedBattleClanId].players.push(member);
              } else {
                if (!enemyGroups['unknown']) {
                  enemyGroups['unknown'] = { clanName: 'Неизвестный', players: [] };
                }
                enemyGroups['unknown'].players.push(member);
              }
            }
          });
          const clanlessList = techClan.members.filter(member => member.classification === 'clanless');
          return {
            clanId: techClan.clanId,
            clanName: techClan.clanName,
            inviteGroups,
            enemyGroups,
            clanlessList
          };
        });
        // Вывод результатов на экран
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '';
        results.forEach(clan => {
          const clanContainer = document.createElement('div');
          clanContainer.style.marginBottom = '20px';
          const title = document.createElement('h3');
          title.textContent = clan.clanName;
          clanContainer.appendChild(title);
          const columns = document.createElement('div');
          columns.style.display = 'flex';
          columns.style.gap = '10px';
          const inviteCollapsible = createGroupedCollapsible(clan.inviteGroups, 'Нужно пригласить', 'invite');
          const enemyCollapsible = createGroupedCollapsible(clan.enemyGroups, 'Ушёл во вражеские кланы', 'enemy');
          const clanlessCollapsible = createCollapsible('Без клана', clan.clanlessList, 'clanless');
          columns.appendChild(inviteCollapsible);
          columns.appendChild(enemyCollapsible);
          columns.appendChild(clanlessCollapsible);
          clanContainer.appendChild(columns);
          resultsDiv.appendChild(clanContainer);
        });
        // Вывод сырых данных для дебага
        document.getElementById('rawData').value = JSON.stringify(results, null, 2);
      }

      // Функции для сохранения/загрузки значений полей из localStorage
      function saveField(id) {
        const value = document.getElementById(id).value;
        localStorage.setItem(id, value);
      }
      function loadField(id) {
        const value = localStorage.getItem(id);
        if (value !== null) {
          document.getElementById(id).value = value;
        }
      }
      ['techClans', 'battleClans', 'excludePlayers'].forEach(loadField);
      const savedResults = localStorage.getItem('results');
      if (savedResults) {
        document.getElementById('results').innerHTML = savedResults;
      }
      ['techClans', 'battleClans', 'excludePlayers'].forEach(id => {
        document.getElementById(id).addEventListener('input', () => saveField(id));
      });

      function animateStatus(messageElement, baseText) {
        let dots = 0;
        return setInterval(() => {
          dots = (dots + 1) % 5;
          messageElement.textContent = baseText + '.'.repeat(dots);
        }, 1000);
      }
      const statusEl = document.getElementById('statusMessage');
      document.getElementById('processBtn').addEventListener('click', async () => {
        console.log('Обработка началась');
        const techClans = document.getElementById('techClans').value;
        const battleClans = document.getElementById('battleClans').value;
        const excludePlayers = document.getElementById('excludePlayers').value;
        console.log('Отправляем данные:', { techClans, battleClans, excludePlayers });
        statusEl.style.color = 'blue';
        let baseStatus = 'Ваш запрос отправлен. Ожидайте, пожалуйста';
        statusEl.textContent = baseStatus;
        const startTime = Date.now();
        const intervalId = animateStatus(statusEl, baseStatus);
        try {
          const res = await fetch('/.netlify/functions/process2', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              techClanIds: techClans,
              battleClanIds: battleClans,
              excludePlayers: excludePlayers
            })
          });
          console.log('Ответ сервера:', res.status, res.statusText);
          clearInterval(intervalId);
          const elapsed = Math.round((Date.now() - startTime) / 1000);
          if (!res.ok) {
            statusEl.style.color = 'red';
            statusEl.textContent = `Возникла ошибка при обработке запроса. Запрос обрабатывался ${elapsed} секунд.`;
            throw new Error(`Ошибка запроса: ${res.status} ${res.statusText}`);
          }
          const data = await res.json();
          console.log('Полученные данные:', data);
          renderResults(data);
          localStorage.setItem('results', document.getElementById('results').innerHTML);
          statusEl.style.color = 'green';
          statusEl.textContent = `Ваш запрос обработан за ${elapsed} секунд.`;
        } catch (error) {
          console.error('Ошибка при обработке запроса:', error);
          clearInterval(intervalId);
          const elapsed = Math.round((Date.now() - startTime) / 1000);
          statusEl.style.color = 'red';
          statusEl.textContent = `Возникла ошибка при обработке запроса. Запрос обрабатывался ${elapsed} секунд.`;
          document.getElementById('results').innerText = 'Ошибка: ' + error.message;
        }
      });
    });
  </script>
</body>
</html>
