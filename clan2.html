<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="windows-1251">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Администрирование тех. клана</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .container { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; }
    .field { flex: 1; min-width: 300px; }
    /* Новый контейнер для разделённого поля ввода */
    .split-field {
      display: flex;
      gap: 10px;
    }
    /* Левая (редактируемая) часть – 16.67% */
    .left-input {
      width: 16.67%;
      height: 100px;
      font-family: monospace;
    }
    /* Правая (только чтение) часть – 83.33% */
    .right-output {
      width: 83.33%;
      height: 100px;
      font-family: monospace;
    }
    button { padding: 10px 20px; font-size: 16px; }
    .collapsible { margin-bottom: 10px; border: 1px solid #ccc; }
    .collapsible-header { background-color: #f0f0f0; padding: 5px; cursor: pointer; }
    .collapsible-list { margin: 0; padding: 5px; }
    table { width: 100%; border-collapse: collapse; }
    td { border: 1px solid #ccc; padding: 5px; text-align: left; }
    td a { text-decoration: none; color: blue; }
    td a:hover { text-decoration: underline; }
    .remove-button { color: red; border: none; background: none; cursor: pointer; }
    #statusMessage { font-size: 16px; margin-bottom: 10px; }
  </style>
</head>
<body>
  <h1>Администрирование тех. клана</h1>
  <div class="container">
    <!-- Технические кланы -->
    <div class="field">
      <h3>Технические кланы<br/>(ID, по одному в строке)</h3>
      <div class="split-field">
        <textarea class="left-input" id="techClans">9098</textarea>
        <textarea class="right-output" id="techClansOutput" readonly></textarea>
      </div>
    </div>
    <!-- Боевые кланы -->
    <div class="field">
      <h3>Боевые кланы<br/>(ID, по одному в строке)</h3>
      <div class="split-field">
        <textarea class="left-input" id="battleClans">1209
7490
7705
9595
5722</textarea>
        <textarea class="right-output" id="battleClansOutput" readonly></textarea>
      </div>
    </div>
    <!-- Особенные игроки -->
    <div class="field">
      <h3>Особенные игроки<br/>(ID, по одному в строке)</h3>
      <div class="split-field">
        <textarea class="left-input" id="excludePlayers"></textarea>
        <textarea class="right-output" id="excludePlayersOutput" readonly></textarea>
      </div>
    </div>
  </div>
  <!-- Элемент для статуса запроса -->
  <div id="statusMessage"></div>
  <button id="processBtn">Обработать</button>
  <h2>Результаты:</h2>
  <div id="results"></div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      console.log('clan2.html loaded');

      // Функция обновления правых полей по содержимому левых
      function updateRightInput(leftId, rightId) {
        const left = document.getElementById(leftId);
        const right = document.getElementById(rightId);
        if (left && right) {
          right.value = left.value;
        }
      }
      // При изменении каждого левого поля обновляем соответствующее правое и сохраняем в localStorage
      ['techClans', 'battleClans', 'excludePlayers'].forEach(id => {
        const left = document.getElementById(id);
        const right = document.getElementById(id + 'Output');
        if (left && right) {
          updateRightInput(id, id + 'Output');
          left.addEventListener('input', () => {
            updateRightInput(id, id + 'Output');
            saveField(id);
          });
        }
      });

      // Функции для работы со сворачиваемыми блоками
      function findClosestGrouped(el) {
        while (el) {
          if (el.nodeType === Node.ELEMENT_NODE && el.classList.contains('grouped')) {
            return el;
          }
          el = el.parentNode;
        }
        return null;
      }
      function updateGroupedHeader(groupedContainer) {
        const contentDiv = groupedContainer.children[1];
        let total = 0;
        if (contentDiv) {
          for (let i = 0; i < contentDiv.children.length; i++) {
            const inner = contentDiv.children[i];
            const innerHeader = inner.querySelector('.collapsible-header');
            if (innerHeader) {
              const match = innerHeader.textContent.match(/\((\d+)\)/);
              if (match) { total += parseInt(match[1], 10); }
            }
          }
        }
        const outerHeader = groupedContainer.firstElementChild;
        if (outerHeader) {
          const baseText = outerHeader.dataset.basetitle || outerHeader.textContent.split('(')[0].trim();
          outerHeader.dataset.basetitle = baseText;
          outerHeader.textContent = `${baseText} (${total})`;
        }
      }
      function createPlayerTable(items, groupType) {
        const table = document.createElement('table');
        items.forEach(item => {
          const tr = document.createElement('tr');
          const tdId = document.createElement('td');
          tdId.textContent = item.id;
          tr.appendChild(tdId);
          const tdName = document.createElement('td');
          const aName = document.createElement('a');
          aName.href = `https://www.heroeswm.ru/pl_info.php?id=${item.id}`;
          aName.target = '_blank';
          aName.textContent = item.name;
          tdName.appendChild(aName);
          tr.appendChild(tdName);
          const tdButton = document.createElement('td');
          const btn = document.createElement('button');
          btn.textContent = '✖';
          btn.classList.add('remove-button');
          // Ваша версия кода для удаления строки и обновления счётчиков:
          btn.addEventListener('click', () => {
              let outerGrouped = tr;
              while (outerGrouped && (outerGrouped.nodeType !== Node.ELEMENT_NODE || !outerGrouped.classList.contains('grouped'))) {
                  outerGrouped = outerGrouped.parentNode;
              }
              if (outerGrouped) {
                console.log("Найден outerGrouped до удаления:", outerGrouped);
              } else {
                console.log("outerGrouped не найден для строки (до удаления):", tr);
              }
              
              const parentTable = tr.parentElement;
              tr.remove();
              
              const collapsible = parentTable.closest('.collapsible');
              if (collapsible) {
                const header = collapsible.querySelector('.collapsible-header');
                const newCount = parentTable.querySelectorAll('tr').length;
                header.textContent = header.textContent.replace(/\(\d+\)/, `(${newCount})`);
                console.log("Внутренний счётчик обновлён:", header.textContent);
              }
              
              if (outerGrouped) {
                updateGroupedHeader(outerGrouped);
              } else {
                console.log("outerGrouped не найден для строки после удаления:", tr);
              }
              
              const excludeTextarea = document.getElementById('excludePlayers');
              let currentExcludes = excludeTextarea.value.split('\n').map(s => s.trim()).filter(Boolean);
              if (!currentExcludes.includes(item.id)) {
                currentExcludes.push(item.id);
                excludeTextarea.value = currentExcludes.join('\n');
                localStorage.setItem('excludePlayers', excludeTextarea.value);
                updateRightInput('excludePlayers', 'excludePlayersOutput');
              }
          });
          tdButton.appendChild(btn);
          tr.appendChild(tdButton);
          table.appendChild(tr);
        });
        return table;
      }
      function createCollapsible(title, items, groupType) {
        const container = document.createElement('div');
        container.classList.add('collapsible');
        const header = document.createElement('div');
        header.classList.add('collapsible-header');
        header.textContent = title + ' (' + items.length + ')';
        container.appendChild(header);
        const content = document.createElement('div');
        content.style.display = 'none';
        const table = createPlayerTable(items, groupType);
        content.appendChild(table);
        container.appendChild(content);
        header.addEventListener('click', () => {
          content.style.display = content.style.display === 'none' ? 'block' : 'none';
        });
        return container;
      }
      function createGroupedCollapsible(groupedData, title, groupType) {
        const container = document.createElement('div');
        container.classList.add('collapsible', 'grouped');
        let totalCount = 0;
        Object.values(groupedData).forEach(group => {
          totalCount += group.players.length;
        });
        const header = document.createElement('div');
        header.classList.add('collapsible-header');
        header.dataset.basetitle = title;
        header.textContent = title + ' (' + totalCount + ')';
        container.appendChild(header);
        const content = document.createElement('div');
        content.style.display = 'none';
        Object.keys(groupedData).forEach(key => {
          const group = groupedData[key];
          const groupCollapsible = createCollapsible(group.clanName, group.players, groupType);
          content.appendChild(groupCollapsible);
        });
        container.appendChild(content);
        header.addEventListener('click', () => {
          content.style.display = content.style.display === 'none' ? 'block' : 'none';
        });
        return container;
      }

      // Упрощённый парсинг HTML-страницы боевого клана
      function parseBattleClan(html, battleClanId) {
        let h1Start = html.indexOf("<h1");
        if (h1Start === -1) return { clanName: "", members: [] };
        let h1End = html.indexOf("</h1>", h1Start);
        if (h1End === -1) h1End = html.length;
        let h1Content = html.substring(h1Start, h1End);
        let bStart = h1Content.indexOf("<b>");
        let bEnd = h1Content.indexOf("</b>", bStart);
        let clanName = "";
        if (bStart !== -1 && bEnd !== -1) {
          clanName = h1Content.substring(bStart + 3, bEnd).trim();
        }
        let tableIndex = html.lastIndexOf("<table");
        if (tableIndex === -1) return { clanName, members: [] };
        let tableEnd = html.indexOf("</table>", tableIndex);
        if (tableEnd === -1) tableEnd = html.length;
        let tableContent = html.substring(tableIndex, tableEnd);
        let members = [];
        let pos = 0;
        while (true) {
          let trStart = tableContent.indexOf("<tr", pos);
          if (trStart === -1) break;
          let trEnd = tableContent.indexOf("</tr>", trStart);
          if (trEnd === -1) break;
          let trContent = tableContent.substring(trStart, trEnd);
          let anchorIndex = trContent.indexOf("pl_info.php?id=");
          if (anchorIndex !== -1) {
            let idStart = anchorIndex + "pl_info.php?id=".length;
            let idEnd = trContent.indexOf("'", idStart);
            if (idEnd === -1) { idEnd = trContent.indexOf("\"", idStart); }
            if (idEnd !== -1) {
              let playerId = trContent.substring(idStart, idEnd).trim();
              let nameStart = trContent.indexOf(">", idEnd);
              if (nameStart !== -1) {
                nameStart++;
                let nameEnd = trContent.indexOf("<", nameStart);
                if (nameEnd !== -1) {
                  let playerName = trContent.substring(nameStart, nameEnd).trim();
                  let tdLastIndex = trContent.lastIndexOf("<td");
                  let score = "0";
                  if (tdLastIndex !== -1) {
                    let tdStart = trContent.indexOf(">", tdLastIndex);
                    if (tdStart !== -1) {
                      tdStart++;
                      let tdEnd = trContent.indexOf("</td>", tdStart);
                      if (tdEnd !== -1) {
                        let tdContent = trContent.substring(tdStart, tdEnd);
                        tdContent = tdContent.replace(/<[^>]*>/g, "").replace(/&nbsp;/g, "").trim();
                        score = tdContent === "" ? "0" : tdContent;
                      }
                    }
                  }
                  members.push({
                    id: playerId,
                    name: playerName,
                    classification: 'member',
                    joinedBattleClanId: battleClanId,
                    joinedBattleClanName: clanName,
                    score: score
                  });
                }
              }
            }
          }
          pos = trEnd + 5;
        }
        return { clanName, members };
      }

      // Упрощённый парсинг HTML-страницы технического клана
      function parseTechClan(html, battleIdsSet) {
        let h1Start = html.indexOf("<h1");
        if (h1Start === -1) return { clanName: "", members: [] };
        let h1End = html.indexOf("</h1>", h1Start);
        if (h1End === -1) h1End = html.length;
        let h1Content = html.substring(h1Start, h1End);
        let bStart = h1Content.indexOf("<b>");
        let bEnd = h1Content.indexOf("</b>", bStart);
        let clanName = "";
        if (bStart !== -1 && bEnd !== -1) {
          clanName = h1Content.substring(bStart + 3, bEnd).trim();
        }
        let tableIndex = html.lastIndexOf("<table");
        if (tableIndex === -1) return { clanName, members: [] };
        let tableEnd = html.indexOf("</table>", tableIndex);
        if (tableEnd === -1) tableEnd = html.length;
        let tableContent = html.substring(tableIndex, tableEnd);
        let members = [];
        let pos = 0;
        while (true) {
          let trStart = tableContent.indexOf("<tr", pos);
          if (trStart === -1) break;
          let trEnd = tableContent.indexOf("</tr>", trStart);
          if (trEnd === -1) break;
          let trContent = tableContent.substring(trStart, trEnd);
          let playerAnchorIndex = trContent.indexOf("pl_info.php?id=");
          if (playerAnchorIndex !== -1) {
            let idStart = playerAnchorIndex + "pl_info.php?id=".length;
            let idEnd = trContent.indexOf("'", idStart);
            if (idEnd === -1) { idEnd = trContent.indexOf("\"", idStart); }
            if (idEnd !== -1) {
              let playerId = trContent.substring(idStart, idEnd).trim();
              let nameStart = trContent.indexOf(">", idEnd);
              if (nameStart !== -1) {
                nameStart++;
                let nameEnd = trContent.indexOf("<", nameStart);
                if (nameEnd !== -1) {
                  let playerName = trContent.substring(nameStart, nameEnd).trim();
                  let prefix = trContent.substring(0, playerAnchorIndex);
                  let joinedBattleClanId = null;
                  let joinedBattleClanName = null;
                  let battleAnchorIndex = prefix.indexOf("clan_info.php?id=");
                  if (battleAnchorIndex !== -1) {
                    let bcidStart = battleAnchorIndex + "clan_info.php?id=".length;
                    let bcidEnd = prefix.indexOf("\"", bcidStart);
                    if (bcidEnd === -1) { bcidEnd = prefix.indexOf("'", bcidStart); }
                    if (bcidEnd !== -1) {
                      joinedBattleClanId = prefix.substring(bcidStart, bcidEnd).trim();
                    }
                    let titleIndex = prefix.indexOf("title='", battleAnchorIndex);
                    if (titleIndex !== -1) {
                      titleIndex += "title='".length;
                      let titleEnd = prefix.indexOf("'", titleIndex);
                      if (titleEnd !== -1) {
                        joinedBattleClanName = prefix.substring(titleIndex, titleEnd).trim();
                      }
                    }
                  }
                  let score = null;
                  let classification = "clanless";
                  if (joinedBattleClanId) {
                    classification = battleIdsSet.has(joinedBattleClanId) ? "member" : "enemy";
                  }
                  members.push({
                    id: playerId,
                    name: playerName,
                    joinedBattleClanId: joinedBattleClanId,
                    joinedBattleClanName: joinedBattleClanName,
                    score: score,
                    classification: classification
                  });
                }
              }
            }
          }
          pos = trEnd + 5;
        }
        return { clanName, members };
      }

      // Функция, которая принимает объект results и динамически создаёт элементы с обработчиками событий
      function displayResults(results) {
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '';
        results.forEach(clan => {
          const clanContainer = document.createElement('div');
          clanContainer.style.marginBottom = '20px';
          const title = document.createElement('h3');
          title.textContent = clan.clanName;
          clanContainer.appendChild(title);
          const columns = document.createElement('div');
          columns.style.display = 'flex';
          columns.style.gap = '10px';
          const inviteCollapsible = createGroupedCollapsible(clan.inviteGroups, 'Нужно пригласить', 'invite');
          const enemyCollapsible = createGroupedCollapsible(clan.enemyGroups, 'Ушёл во вражеские кланы', 'enemy');
          const clanlessCollapsible = createCollapsible('Без клана', clan.clanlessList, 'clanless');
          columns.appendChild(inviteCollapsible);
          columns.appendChild(enemyCollapsible);
          columns.appendChild(clanlessCollapsible);
          clanContainer.appendChild(columns);
          resultsDiv.appendChild(clanContainer);
        });
      }

      // Функция renderResults обрабатывает данные с сервера, формирует объект results и затем вызывает displayResults
      function renderResults(data) {
        const parsedBattleClans = data.battleClans.map(bc => {
          const parsed = parseBattleClan(bc.html, bc.clanId);
          return { clanId: bc.clanId, clanName: parsed.clanName, members: parsed.members };
        });
        const battleMembersMap = new Map();
        parsedBattleClans.forEach(bc => {
          bc.members.forEach(member => {
            battleMembersMap.set(member.id, { clanId: bc.clanId, clanName: bc.clanName });
          });
        });
        const battleIdsSet = new Set(data.battleClans.map(b => b.clanId));
        const parsedTechClans = data.techClans.map(tc => {
          const parsed = parseTechClan(tc.html, battleIdsSet);
          return { clanId: tc.clanId, clanName: parsed.clanName, members: parsed.members };
        });
        const excludeList = document.getElementById('excludePlayers')
          .value.split('\n')
          .map(s => s.trim())
          .filter(Boolean);
        const parsedTechClansFiltered = parsedTechClans.map(techClan => ({
          ...techClan,
          members: techClan.members.filter(member => !excludeList.includes(member.id))
        }));
        const resultsObj = parsedTechClansFiltered.map(techClan => {
          const techMemberIds = new Set(techClan.members.map(m => m.id));
          const inviteGroups = {};
          battleMembersMap.forEach((info, memberId) => {
            if (!techMemberIds.has(memberId)) {
              if (!inviteGroups[info.clanId]) {
                inviteGroups[info.clanId] = { clanName: info.clanName, players: [] };
              }
              const battleClan = parsedBattleClans.find(bc => bc.clanId === info.clanId);
              if (battleClan) {
                const memberDetail = battleClan.members.find(m => m.id === memberId);
                if (memberDetail) {
                  inviteGroups[info.clanId].players.push(memberDetail);
                }
              }
            }
          });
          const enemyGroups = {};
          techClan.members.forEach(member => {
            if (member.classification === 'enemy') {
              if (member.joinedBattleClanId) {
                if (!enemyGroups[member.joinedBattleClanId]) {
                  enemyGroups[member.joinedBattleClanId] = { clanName: member.joinedBattleClanName || 'Неизвестный', players: [] };
                }
                enemyGroups[member.joinedBattleClanId].players.push(member);
              } else {
                if (!enemyGroups['unknown']) {
                  enemyGroups['unknown'] = { clanName: 'Неизвестный', players: [] };
                }
                enemyGroups['unknown'].players.push(member);
              }
            }
          });
          const clanlessList = techClan.members.filter(member => member.classification === 'clanless');
          return {
            clanId: techClan.clanId,
            clanName: techClan.clanName,
            inviteGroups,
            enemyGroups,
            clanlessList
          };
        });
        // Дополнительная фильтрация по excludeList для всех групп
        resultsObj.forEach(clan => {
          Object.keys(clan.inviteGroups).forEach(key => {
            clan.inviteGroups[key].players = clan.inviteGroups[key].players.filter(
              player => !excludeList.includes(player.id)
            );
          });
          Object.keys(clan.enemyGroups).forEach(key => {
            clan.enemyGroups[key].players = clan.enemyGroups[key].players.filter(
              player => !excludeList.includes(player.id)
            );
          });
          clan.clanlessList = clan.clanlessList.filter(
            player => !excludeList.includes(player.id)
          );
        });
        // Отрисовываем динамически результаты
        displayResults(resultsObj);
        // Сохраняем объект results в localStorage как JSON
        localStorage.setItem('results', JSON.stringify(resultsObj));
      }

      // При загрузке страницы, если есть сохранённые результаты (JSON), заново их отрисовываем
      const savedResults = localStorage.getItem('results');
      if (savedResults) {
        const resultsObj = JSON.parse(savedResults);
        displayResults(resultsObj);
      }

      // Сохранение и загрузка входных данных
      function saveField(id) {
        const value = document.getElementById(id).value;
        localStorage.setItem(id, value);
      }
      function loadField(id) {
        const value = localStorage.getItem(id);
        if (value !== null) {
          document.getElementById(id).value = value;
          // Также обновляем правое поле
          updateRightInput(id, id + 'Output');
        }
      }
      ['techClans', 'battleClans', 'excludePlayers'].forEach(loadField);

      document.getElementById('techClans').addEventListener('input', () => saveField('techClans'));
      document.getElementById('battleClans').addEventListener('input', () => saveField('battleClans'));
      document.getElementById('excludePlayers').addEventListener('input', () => saveField('excludePlayers'));

      function animateStatus(messageElement, baseText) {
        let dots = 0;
        return setInterval(() => {
          dots = (dots + 1) % 5;
          messageElement.textContent = baseText + '.'.repeat(dots);
        }, 1000);
      }
      const statusEl = document.getElementById('statusMessage');
      document.getElementById('processBtn').addEventListener('click', async () => {
        console.log('Обработка началась');
        const techClans = document.getElementById('techClans').value;
        const battleClans = document.getElementById('battleClans').value;
        const excludePlayers = document.getElementById('excludePlayers').value;
        console.log('Отправляем данные:', { techClans, battleClans, excludePlayers });
        statusEl.style.color = 'blue';
        let baseStatus = 'Ваш запрос отправлен. Ожидайте, пожалуйста';
        statusEl.textContent = baseStatus;
        const startTime = Date.now();
        const intervalId = animateStatus(statusEl, baseStatus);
        try {
          const res = await fetch('/.netlify/functions/process2', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              techClanIds: techClans,
              battleClanIds: battleClans,
              excludePlayers: excludePlayers
            })
          });
          console.log('Ответ сервера:', res.status, res.statusText);
          clearInterval(intervalId);
          const elapsed = Math.round((Date.now() - startTime) / 1000);
          if (!res.ok) {
            statusEl.style.color = 'red';
            statusEl.textContent = `Возникла ошибка при обработке запроса. Запрос обрабатывался ${elapsed} секунд.`;
            throw new Error(`Ошибка запроса: ${res.status} ${res.statusText}`);
          }
          const data = await res.json();
          console.log('Полученные данные:', data);
          renderResults(data);
          statusEl.style.color = 'green';
          statusEl.textContent = `Ваш запрос обработан за ${elapsed} секунд.`;
        } catch (error) {
          console.error('Ошибка при обработке запроса:', error);
          clearInterval(intervalId);
          const elapsed = Math.round((Date.now() - startTime) / 1000);
          statusEl.style.color = 'red';
          statusEl.textContent = `Возникла ошибка при обработке запроса. Запрос обрабатывался ${elapsed} секунд.`;
          document.getElementById('results').innerText = 'Ошибка: ' + error.message;
        }
      });
    });
  </script>
</body>
</html>
