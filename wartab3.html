<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Анализ боёв с фильтрами и группировкой</title>

  <style>
    /* ------------------ базовая раскраска — без изменений ------------------ */
    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
      background:#f2f2f2;margin:0;padding:0}
    .container{max-width:960px;margin:auto;padding:20px}

    /* ------------------ sticky‑заголовки трёх секций ------------------ */
    :root{                       /* переменные, которые будем пересчитывать */
      --top-base:   60px;        /* отступ под статус‑бар */
      --event-h:    0px;         /* высота раскрытого блока "ивент" */
      --battle-h:   0px;         /* высота раскрытого блока "отправка" */
    }

    .collapsible,
    .filter-header{              /* все три «шапки» */
      position:sticky;
      z-index:1000;
      width:100%;
      padding:18px;
      border:none;
      text-align:left;
      font-size:20px;
      cursor:pointer;
      color:#fff;
      background:#1E4D2B;
      border-radius:4px;
      margin:0 0 5px 0;
    }
    .collapsible:hover{background:#27AE60}

    /* индивидуальные отступы */
    #eventSelectorHeader{top:var(--top-base);}
    #battleToggle{
      top:calc(var(--top-base) + var(--event-h));
      background:#145A32;
    }
    #filterToggle{/* .filter-header имеет этот id */
      top:calc(var(--top-base) + var(--event-h) + var(--battle-h));
    }

    .filter-header{background:#deb887;color:#000;font-weight:bold}
    .filter-header:hover{background:#d2a679}

    /* стрелочки раскрытия */
    .collapsible::after,
    .filter-header::after{
      content:"\25B6";
      position:absolute;right:20px;font-size:20px}
    .collapsible.active::after, .filter-header.active::after{content:"\25BC"}

    /* ------------------ тела секций ------------------ */
    .content{
      display:none;
      background:#fff;
      border:1px solid #ccc;
      border-radius:4px;
      padding:10px 18px;
      margin:0 0 20px 0;
    }
    textarea{width:100%;height:150px;font-size:16px;padding:10px;margin:0 0 10px 0;
             border:1px solid #ccc;border-radius:4px}
    input[type=text]{width:calc(100% - 20px);padding:10px;font-size:16px;margin:0 0 10px 0;
                     border:1px solid #ccc;border-radius:4px}
    button{padding:10px 20px;font-size:16px;border:none;border-radius:4px;cursor:pointer;margin-right:10px}
    button.send{background:#28a745;color:#fff}button.clear{background:#dc3545;color:#fff}

    /* ------------------ фильтр (тело) ------------------ */
    .filter-container{
      background:rgba(240,230,210,.9);
      border:2px solid #8b4513;border-radius:8px;margin-bottom:20px;overflow:hidden;
      transition:max-height .3s ease-out,padding .3s ease-out}
    .filter-content{padding:8px;max-height:70vh;overflow-y:auto}
    .filter-content.collapsed{max-height:0!important;padding-top:0;padding-bottom:0;border:none}

    /* ---------- далее идёт стилизация результатов (без изменений) ---------- */
    .result-group{border:1px solid #ccc;background:#fff;border-radius:4px;margin-bottom:20px;overflow:hidden}
    .collapsible-group{background:#e0e0e0;cursor:pointer;padding:10px;font-size:18px;font-weight:bold;
                       border-bottom:1px solid #ccc;position:sticky;top:0;z-index:900}
    .collapsible-group::after{content:"\25B6";position:absolute;right:10px;font-size:18px}
    .collapsible-group.active::after{content:"\25BC"}
    .group-content{display:none;padding:10px}
    .group-title{font-weight:bold;margin-bottom:5px;padding:5px;background:#f0f0f0;border-radius:4px}

    .battle{border-bottom:1px dashed #ccc;padding:10px 0;margin-bottom:10px}
    .battle:last-child{border-bottom:none}
    .battle-link a{color:#007bff;text-decoration:none}.battle-link a:hover{text-decoration:underline}

    .result-line{padding:5px;border-radius:4px;margin-bottom:3px;font-family:Consolas,"Courier New",monospace}
    .result-line.win{background:#d4edda;color:#155724}
    .result-line.lose{background:#f8d7da;color:#721c24}
    .result-line.unknown{background:#fff3cd;color:#856404}

    /* ------------------ статус‑бар (как было) ------------------ */
    .status-bar{background:#e9ecef;border:2px solid #ced4da;border-radius:8px;padding:10px 20px;
                font-size:18px;margin:20px auto;max-width:960px;text-align:center;color:#495057;
                box-shadow:0 2px 4px rgba(0,0,0,.1);opacity:0;animation:fadeIn .6s ease-in-out forwards}
    @keyframes fadeIn{from{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}
    .status-update{animation:pulse 1.5s infinite}@keyframes pulse{0%{box-shadow:0 0 0 0 rgba(40,167,69,.7)}
      70%{box-shadow:0 0 0 10px rgba(40,167,69,0)}100%{box-shadow:0 0 0 0 rgba(40,167,69,0)}}
    .status-instruction-btn{background:#007bff;color:#fff;border:none;padding:5px 10px;font-size:14px;float:left;
                            border-radius:4px;cursor:pointer} .status-instruction-btn:hover{background:#0056b3}

    .filter-container{
      position:sticky;                               /* ← было забыто  */
      top:calc(var(--top-base) + var(--event-h) + var(--battle-h));
      background:rgba(240,230,210,.9);
      border:2px solid #8b4513;border-radius:8px;
      margin-bottom:20px;overflow:hidden;
      transition:max-height .3s ease-out,padding .3s ease-out;
    }

    /*  #filterToggle теперь обычный flex‑заголовок, топ из него убираем */
    #filterToggle{ top:auto; }

    /* ------------- прочие стили (модалки, ошибки) оставлены без изменений ------------- */
    /* … */
  </style>
</head>
<body>

  <!-- Статус‑бар -->
  <div class="status-bar" id="statusBar">
    <button class="status-instruction-btn" id="instructionToggleBtn">Инструкция</button>
    <span id="statusText">Статус: ожидаем ввода</span>
  </div>

  <div class="container">

    <!-- 1. выбор ивента -->
    <button type="button" class="collapsible" id="eventSelectorHeader">Выбран ивент:</button>
    <div class="content" id="eventSelectorContainer">
      <!-- ваше содержимое без изменений -->
      <div style="margin:10px 0;">
        <label for="eventSelector">Ивент:</label>
        <select id="eventSelector"></select>
      </div>
      <div><strong>Анонс:</strong> <a id="eventAnnouncement" href="#" target="_blank">—</a></div>
      <div><strong>Награждение:</strong> <a id="eventReward" href="#" target="_blank">—</a></div>
      <div><strong>Маркеры:</strong> <span id="eventMarkersDisplay">—</span></div>
    </div>

    <!-- 2. отправка боёв -->
    <button type="button" class="collapsible" id="battleToggle">Отправка боёв</button>
    <div class="content" id="battleContent">
      <!-- форма отправки без изменений -->
      <textarea id="battleInput" placeholder="Вставьте сюда текст…"></textarea>
      <input type="text" id="markersInput" placeholder="Маркеры ивента (через запятую)">
      <div>
        <button class="send"  id="sendButton">Отправить</button>
        <button class="clear" id="clearButton">Очистить</button>
      </div>
    </div>

    <!-- 3. фильтр -->
    <div class="filter-container" id="filterContainer">
      <div class="filter-header" id="filterToggle">
        Фильтры <span id="filterToggleIcon">&#9654;</span>
      </div>
      <div class="filter-content collapsed" id="filterContent">
        <div class="filter-group common-options">
          <div class="group-title">Общие опции</div>
          <div class="group-content">
            <div>
              <input type="checkbox" id="shortenMarkers" data-option="shortenMarkers">
              <label for="shortenMarkers">Сокращать маркеры</label>
            </div>
          </div>
        </div>
        <div class="two-columns">
          <div class="column">
            <div class="group-title">Победители</div>
            <!-- Здесь ваши опции для победителей -->
            <div class="option">
              <input type="checkbox" id="showWinningSideName" data-option="showWinningSideName">
              <label for="showWinningSideName">Название стороны</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showWinningHP" data-option="showWinningHP">
              <label for="showWinningHP">Суммарное ХП</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showWinningPercent" data-option="showWinningPercent">
              <label for="showWinningPercent">% выживших</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showWinningFaction" data-option="showWinningFaction">
              <label for="showWinningFaction">Фракция</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showWinningHeroInfo" data-option="showWinningHeroInfo">
              <label for="showWinningHeroInfo">Информация о героях</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showWinningHeroNickname" data-option="showWinningHeroNickname">
              <label for="showWinningHeroNickname">Никнейм героев</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showWinningHeroLevel" data-option="showWinningHeroLevel">
              <label for="showWinningHeroLevel">Уровень героев</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showWinningHeroParams" data-option="showWinningHeroParams">
              <label for="showWinningHeroParams">Параметры героев</label>
            </div>
            <div class="option">
              <input type="checkbox" id="shortenWinningHeroParams" data-option="shortenWinningHeroParams">
              <label for="shortenWinningHeroParams">Сокращать параметры героев</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showWinningArmy" data-option="showWinningArmy">
              <label for="showWinningArmy">Армия</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showWinningBonuses" data-option="showWinningBonuses">
              <label for="showWinningBonuses">Бонусы</label>
            </div>
          </div>
          <div class="column">
            <div class="group-title">Проигравшие</div>
            <!-- Здесь ваши опции для проигравших -->
            <div class="option">
              <input type="checkbox" id="showLosingSideName" data-option="showLosingSideName">
              <label for="showLosingSideName">Название стороны</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showLosingHP" data-option="showLosingHP">
              <label for="showLosingHP">Суммарное ХП</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showLosingPercent" data-option="showLosingPercent">
              <label for="showLosingPercent">% выживших</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showLosingFaction" data-option="showLosingFaction">
              <label for="showLosingFaction">Фракция</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showLosingHeroInfo" data-option="showLosingHeroInfo">
              <label for="showLosingHeroInfo">Информация о героях</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showLosingHeroNickname" data-option="showLosingHeroNickname">
              <label for="showLosingHeroNickname">Никнейм героев</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showLosingHeroLevel" data-option="showLosingHeroLevel">
              <label for="showLosingHeroLevel">Уровень героев</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showLosingHeroParams" data-option="showLosingHeroParams">
              <label for="showLosingHeroParams">Параметры героев</label>
            </div>
            <div class="option">
              <input type="checkbox" id="shortenLosingHeroParams" data-option="shortenLosingHeroParams">
              <label for="shortenLosingHeroParams">Сокращать параметры героев</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showLosingArmy" data-option="showLosingArmy">
              <label for="showLosingArmy">Армия</label>
            </div>
            <div class="option">
              <input type="checkbox" id="showLosingBonuses" data-option="showLosingBonuses">
              <label for="showLosingBonuses">Бонусы</label>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- результаты -->
    <div id="resultsContainer"></div>
  </div>


  <!-- =============================== SCRIPT =============================== -->
  <script>
  /***************** ФУНКЦИЯ ПЕРЕСЧЁТА ВЫСОТ sticky‑блоков *****************/
  function recalcStickyOffsets () {
      /* реальные высоты заголовков */
      const hEvtHdr = document.getElementById('eventSelectorHeader').offsetHeight;
      const hBatHdr = document.getElementById('battleToggle').offsetHeight;

      const bodyEvt = document.getElementById('eventSelectorContainer');
      const bodyBat = document.getElementById('battleContent');

      const evtOpen = getComputedStyle(bodyEvt).display !== 'none';
      const batOpen = getComputedStyle(bodyBat).display !== 'none';

      const eventBlockH  = hEvtHdr + (evtOpen ? bodyEvt.offsetHeight  : 0);
      const battleBlockH = hBatHdr + (batOpen ? bodyBat.offsetHeight : 0);

      document.documentElement.style.setProperty('--event-h',  eventBlockH  + 'px');
      document.documentElement.style.setProperty('--battle-h', battleBlockH + 'px');
    }

  document.addEventListener('DOMContentLoaded', async ()=>{

    /* первичный пересчёт + пересчёт при ресайзе */
    recalcStickyOffsets();
    window.addEventListener('resize',recalcStickyOffsets);

      // Общие переменные и элементы
      const statusBar = document.getElementById('statusBar');
      const battleToggle = document.getElementById('battleToggle');

      const battleInput = document.getElementById('battleInput');
      const markersInput = document.getElementById('markersInput');
      const sendButton = document.getElementById('sendButton');
      const clearButton = document.getElementById('clearButton');
      const resultsContainer = document.getElementById('resultsContainer');
      const eventSelectorHeader    = document.getElementById('eventSelectorHeader');
    const eventSelectorContainer = document.getElementById('eventSelectorContainer');
    const eventSelector          = document.getElementById('eventSelector');
    const eventAnnouncement      = document.getElementById('eventAnnouncement');
    const eventReward            = document.getElementById('eventReward');
    const eventMarkersDisplay    = document.getElementById('eventMarkersDisplay');

      /* Функция для начала "активного" состояния статус-бара */
      function startStatusUpdate() {
        console.log("startStatusUpdate вызвана в " + new Date().toLocaleTimeString());
        statusBar.classList.add('status-update');
      }

      /* Функция для остановки анимации обновления */
      function stopStatusUpdate() {
        console.log("stopStatusUpdate вызвана в " + new Date().toLocaleTimeString());
        statusBar.classList.remove('status-update');
      }

      clearButton.addEventListener('click', function() {
        battleInput.value = '';
        document.getElementById('statusText').textContent = 'Статус: очищено';
      });

      /* Основной обработчик кнопки "Отправить" */
      sendButton.addEventListener('click', async function() {
        document.getElementById('statusText').textContent = 'Статус: обработка ввода...';
        // 1) Свернуть блок "Отправка боёв", если он открыт
        if (battleToggle.classList.contains('active')) {
          battleToggle.classList.remove('active');
          battleToggle.nextElementSibling.style.display = 'none';
          recalcStickyOffsets();
        }

        // 2) Прокрутить к статус-бару (чтобы пользователь увидел ход выполнения)
        statusBar.scrollIntoView({ behavior: 'smooth' });
        const inputText = battleInput.value;
        if (!inputText.trim()) {
          document.getElementById('statusText').textContent = 'Статус: пустой ввод';
          return;
        }

        // Извлекаем ссылки на бои из введённого текста
        let battleLinks = extractBattleLinks(inputText);
        if (battleLinks.length === 0) {
          document.getElementById('statusText').textContent = 'Статус: не найдено ссылок на бои';
          return;
        }

        // Приводим ссылки к нужной форме и извлекаем warid
        let newBattles = battleLinks.map(link => {
          const normalized = normalizeBattleLink(link);
          const warid = extractWarId(normalized);
          return { warid, link: normalized, result: null };
        }).filter(b => b.warid);

        // Получаем уже сохранённые в базе бои
        let dbBattles = [];
        try {
          const res = await fetch('/.netlify/functions/getBattles');
          if (res.ok) {
            const data = await res.json();
            // Извлекаем массив боёв из поля battles
            dbBattles = data.battles || [];
          } else {
            console.error("Ошибка получения боёв из базы");
          }
        } catch (error) {
          console.error("Ошибка при запросе к базе:", error);
        }

        // Объединяем: если бой с таким warid уже существует – оставляем его (с результатом анализа)
        let battlesMap = {};
        dbBattles.forEach(b => { battlesMap[b.warid] = b; });
        newBattles.forEach(b => {
          if (!battlesMap[b.warid]) battlesMap[b.warid] = b;
        });
        let allBattles = Object.values(battlesMap);

        document.getElementById('statusText').textContent = `Статус: ${allBattles.length} боёв, ожидание анализа...`;

        // Анализируем те бои, у которых ещё нет результата
        allBattles = await analyzeBattles(allBattles);

        // Если заданы маркеры ивента – фильтруем
        const markers = markersInput.value.split(',')
                              .map(m => m.trim())
                              .filter(m => m);
        if (markers.length > 0) {
          allBattles = allBattles.filter(b => battleHasMarkers(b.result, markers));
        }

        // Определяем, какие бои новые (т.е. отсутствовали в базе)
        let newInDB = allBattles.filter(b => !dbBattles.some(db => db.warid === b.warid));

        // Если есть новые бои – отправляем их пачкой в базу данных
        if (newInDB.length > 0) {
          try {
            // Формируем объект с полями: battles и markers
            const payload = {
              battles: newInDB,
              markers: markersInput.value // текущее значение из поля ввода
            };
            const updateRes = await fetch('/.netlify/functions/updateBattles', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            if (!updateRes.ok) {
              console.error("Ошибка обновления базы");
            }
          } catch (error) {
            console.error("Ошибка при обновлении базы:", error);
          }
        }

        // Отображаем объединённый результат (группировка без изменений)
        displayBattles(allBattles);
        updateFilteredOutput();
        document.getElementById('statusText').textContent = `Статус: обработка завершена. Всего боёв: ${allBattles.length}`;
      });

      /* Функции для работы со ссылками и идентификатором боя */
      function extractBattleLinks(text) {
        const regex = /(?:https?:\/\/[^\s'"]+)?\/?(war(?:log)?\.php\?[^"'\s]+)/gi;
        let links = [];
        let match;
        while ((match = regex.exec(text)) !== null) {
          links.push(match[1]);
        }
        return links;
      }

      function normalizeBattleLink(link) {
        if (!link.startsWith('http')) {
          link = 'https://www.heroeswm.ru/' + link;
        } else {
          link = link.replace(/https?:\/\/(www\.heroeswm\.ru|mirror\.heroeswm\.ru|my\.lordswm\.com|www\.lordswm\.com|lordswm\.com)/i, 'https://www.heroeswm.ru');
        }
        link = link.replace(/warlog\.php/gi, 'war.php');
        try {
          let url = new URL(link);
          url.searchParams.delete('lt');
          return url.toString();
        } catch (e) {
          console.error('Ошибка нормализации ссылки:', link, e);
          return link;
        }
      }

      function extractWarId(link) {
        try {
          let url = new URL(link);
          return url.searchParams.get('warid');
        } catch (e) {
          console.error('Ошибка извлечения warid из ссылки:', link, e);
          return null;
        }
      }

      /* Функция анализа боёв (оставляем существующую реализацию) */
      async function analyzeBattles(battles) {
          const toAnalyze = battles.filter(b => !b.result);
          const total     = toAnalyze.length;
          const BATCH_SIZE   = 200;
          const MAX_ATTEMPTS = 5;

          let permanentlyFailed = [];
          let processed = 0;
          const t0 = performance.now();

          for (let i = 0; i < total; i += BATCH_SIZE) {
            const chunk = toAnalyze.slice(i, i + BATCH_SIZE);
            let attempt = 1,
                success = false;

            while (attempt <= MAX_ATTEMPTS && !success) {
              // обновляем статус перед каждой попыткой
              const elapsed = ((performance.now() - t0) / 1000).toFixed(3);
              statusText.textContent = 
                `Статус: ${processed}/${total} боёв. ` +
                `Отправлено ${chunk.length} ссылок, попытка ${attempt}/${MAX_ATTEMPTS}. ` +
                `Время: ${elapsed} сек`;

              try {
                const res = await fetch(
                  'https://heroeswm.netlify.app/.netlify/functions/analyzeBattles',
                  {
                    method: 'POST',
                    headers: {'Content-Type':'application/json'},
                    body: JSON.stringify({ links: chunk.map(b=>b.link) })
                  }
                );
                if (!res.ok) {
                  attempt++;
                  await new Promise(r=>setTimeout(r,1000));
                  continue;
                }
                const data = await res.json();
                if (!Array.isArray(data.results)) {
                  attempt++;
                  await new Promise(r=>setTimeout(r,1000));
                  continue;
                }

                // Пометить результаты как готовые
                data.results.forEach(r => {
                  const b = battles.find(x => x.link === r.link);
                  if (b && r.status === 'success' && r.result) {
                    b.result = r.result;
                    processed++;
                  }
                });
                success = true;
              } catch (err) {
                attempt++;
                await new Promise(r=>setTimeout(r,1000));
              }
            }

            if (!success) {
              permanentlyFailed.push(...chunk);
            }
          }

          // Финальное обновление статуса
          const totalElapsed = ((performance.now() - t0) / 1000).toFixed(3);
          statusText.textContent = 
            `Анализ завершён: ${processed}/${total} боёв за ${totalElapsed} сек`;

          if (permanentlyFailed.length) {
            showAnalysisErrorModal(permanentlyFailed);
            battles = battles.filter(b => b.result !== null);
          }

          return battles;
        }


    function showAnalysisErrorModal(failedBattles) {
  let modalOverlay = document.createElement('div');
  modalOverlay.id = 'errorModalOverlay';

  let modal = document.createElement('div');
  modal.id = 'errorModal';

  modal.innerHTML = `
    <h2>Ошибка анализа</h2>
    <p>
      Следующие бои не удалось проанализировать (повторных попыток более 5):
    </p>
    <!-- Вместо списка используем textarea -->
    <textarea id="failedBattlesTextarea" readonly style="width:100%; height:150px; font-family: Consolas, 'Courier New', monospace; padding:10px; border:1px solid #ccc; border-radius:4px; resize:vertical;">
${failedBattles.map(b => b.link).join('\n')}
    </textarea>
    <p>Однако все остальные бои были добавлены!</p>
    <div style="text-align: right;">
      <button class="error-btn copy" id="copyFailedBtn">Скопировать</button>
      <button class="error-btn close" id="closeErrorModalBtn">Закрыть</button>
    </div>
  `;

  modalOverlay.appendChild(modal);
  document.body.appendChild(modalOverlay);

  document.getElementById('copyFailedBtn').addEventListener('click', () => {
    let tempTextarea = document.createElement('textarea');
    tempTextarea.value = failedBattles.map(b => b.link).join('\n');
    document.body.appendChild(tempTextarea);
    tempTextarea.select();
    document.execCommand('copy');
    document.body.removeChild(tempTextarea);
    alert('Ссылки скопированы!');
  });

  document.getElementById('closeErrorModalBtn').addEventListener('click', () => {
    document.body.removeChild(modalOverlay);
  });
}



      function battleHasMarkers(result, markers) {
        if (!result) return false;
        return markers.some(marker => {
          const regex = new RegExp('\\[' + marker + '(\\s*[({]|\\])', 'i');
          return regex.test(result);
        });
      }
      
      const defaultFilterOptions = {
          shortenMarkers: true,
          showWinningSideName: true,
          showLosingSideName: true,
          showWinningHP: false,
          showLosingHP: true,
          showWinningPercent: true,
          showLosingPercent: false,
          showWinningFaction: true,
          showLosingFaction: true,
          showWinningHeroInfo: false,
          showLosingHeroInfo: true,
          showWinningHeroNickname: false,
          showLosingHeroNickname: true,
          showWinningHeroLevel: false,
          showLosingHeroLevel: true,
          showWinningHeroParams: false,
          showLosingHeroParams: true,
          shortenWinningHeroParams: false,
          shortenLosingHeroParams: true,
          showWinningArmy: false,
          showLosingArmy: true,
          showWinningBonuses: true,
          showLosingBonuses: false
    };
    function loadFilterOptions() {
      let stored = localStorage.getItem("battleFilterOptions");
      if (stored) {
        try {
          return JSON.parse(stored);
        } catch (e) {
          return Object.assign({}, defaultFilterOptions);
        }
      }
      return Object.assign({}, defaultFilterOptions);
    }
    function saveFilterOptions(options) {
      localStorage.setItem("battleFilterOptions", JSON.stringify(options));
    }
    let filterOptions = loadFilterOptions();
    document.querySelectorAll("#filterContent input[type=checkbox]").forEach(cb => {
      let option = cb.getAttribute("data-option");
      cb.checked = !!filterOptions[option];
      cb.addEventListener("change", function() {
        filterOptions[option] = this.checked;
        saveFilterOptions(filterOptions);
        updateFilteredOutput();
      });
    });
      /* Функции для дополнительной группировки и фильтрации */
      function extractWinningLevel(resultText, markers) {
          if (!resultText) return "Без уровня";
          let lines = resultText.split('\n').map(l => l.trim());
          let maxLevel = 0;
          outer: for (let line of lines) {
            // Если строка содержит хотя бы один из маркеров, пропускаем её
            for (let marker of markers) {
              if (line.toLowerCase().includes(marker.toLowerCase())) {
                continue outer;
              }
            }
            // Если строка не содержит маркеров, пробуем извлечь уровень
            let match = line.match(/\[Уровень:\s*(\d+)\]/i);
            if (match) {
              maxLevel = Math.max(maxLevel, parseInt(match[1], 10));
            }
          }
          if (maxLevel !== 0) {
            return "[Уровень: " + maxLevel + "]";
          }
          return "Без уровня";
        }


      function extractFaction(result) {
        if (!result) return "Без фракции";
        let lines = result.split('\n').map(l => l.trim());
        for (let line of lines) {
          if (line.toLowerCase().startsWith('[win') || line.startsWith('[+]')) {
            let blocks = [];
            const regex = /\[([^\]]+)\]/g;
            let match;
            while ((match = regex.exec(line)) !== null) {
              blocks.push(match[1].trim());
            }
            if (blocks.length >= 5) return blocks[4];
          }
        }
        return "Без фракции";
      }

      function extractSurvivalPercent(result, markers) {
          if (!result) return 0;
          let lines = result.split('\n').map(l => l.trim());
          let maxSurv = 0.0;
          outer: for (let line of lines) {
            // Если строка содержит хотя бы один из маркеров, пропускаем её
            for (let marker of markers) {
              if (line.toLowerCase().includes(marker.toLowerCase())) {
                continue outer;
              }
            }
            let blocks = [];
            const regex = /\[([^\]]+)\]/g;
            let match;
            while ((match = regex.exec(line)) !== null) {
              blocks.push(match[1].trim());
            }
            if (blocks.length >= 4) {
              let percentMatch = blocks[3].match(/(\d+(\.\d+)?)%/);
              if (percentMatch) {
                maxSurv = Math.max(maxSurv, parseFloat(percentMatch[1]));
              }
            }
          }
          return maxSurv;
        }


      function updateFilteredOutput() {
        document.querySelectorAll('.battle-result').forEach(resultDiv => {
          let original = resultDiv.parentNode.dataset.originalResult;
          if (!original) return;
          resultDiv.innerHTML = "";
          let lines = original.split('\n');
          lines.forEach(line => {
            let newLine = transformLine(line, filterOptions);
            let lineDiv = document.createElement('div');
            lineDiv.className = 'result-line';
            lineDiv.textContent = newLine;
            if (newLine.startsWith('[win!]') || newLine.startsWith('[+]')) {
              lineDiv.classList.add('win');
            } else if (newLine.startsWith('[lose]') || newLine.startsWith('[-]')) {
              lineDiv.classList.add('lose');
            } else if (newLine.startsWith('[?]')) {
              lineDiv.classList.add('unknown');
            }
            resultDiv.appendChild(lineDiv);
          });
        });
      }

      function shortenHeroParams(paramsBlock) {
        const mapping = {
          "Нападение:": "Н:",
          "Защита:": "З:",
          "Сила магии:": "СМ:",
          "Знания:": "ЗН:",
          "Удача:": "Уд:",
          "Боевой Дух:": "БД:",
          "Уровень:": "У:"
        };
        for (let key in mapping) {
          let shortKey = mapping[key];
          let regex = new RegExp(key, "gi");
          paramsBlock = paramsBlock.replace(regex, shortKey);
        }
        return paramsBlock.replace(/\s+/g, "");
      }

      function transformHeroBlock(heroBlock, isWinner, opts) {
        if ((isWinner && !opts.showWinningHeroInfo) || (!isWinner && !opts.showLosingHeroInfo))
          return "";
        let firstBracket = heroBlock.indexOf("[");
        let nickname = "";
        let blocks = [];
        if (firstBracket !== -1) {
          nickname = heroBlock.substring(0, firstBracket).trim();
          let regex = /\[([^\]]+)\]/g;
          let m;
          while ((m = regex.exec(heroBlock)) !== null) {
            blocks.push(m[1]);
          }
        } else {
          nickname = heroBlock.trim();
        }
        let levelBlock = "";
        let paramsBlock = "";
        if (blocks.length > 0) {
          if (/Уровень:|^Ур:/i.test(blocks[0])) {
            levelBlock = blocks[0];
            if (blocks.length > 1) {
              paramsBlock = blocks.slice(1).join("][");
            }
          } else {
            paramsBlock = blocks.join("][");
          }
        }
        if ((isWinner && !opts.showWinningHeroNickname) || (!isWinner && !opts.showLosingHeroNickname))
          nickname = "";
        if (!((isWinner && opts.showWinningHeroLevel) || (!isWinner && opts.showLosingHeroLevel))) {
          levelBlock = "";
        } else if (levelBlock) {
          if ((isWinner && opts.shortenWinningHeroParams) || (!isWinner && opts.shortenLosingHeroParams)) {
            levelBlock = levelBlock.replace(/Уровень:/gi, "Ур:").replace(/\s+/g, "");
          }
          levelBlock = "[" + levelBlock + "]";
        }
        if (!((isWinner && opts.showWinningHeroParams) || (!isWinner && opts.showLosingHeroParams))) {
          paramsBlock = "";
        } else if (paramsBlock) {
          let tmp = "[" + paramsBlock + "]";
          if ((isWinner && opts.shortenWinningHeroParams) || (!isWinner && opts.shortenLosingHeroParams)) {
            tmp = shortenHeroParams(tmp);
          }
          paramsBlock = tmp;
        }
        let result = (nickname + levelBlock + paramsBlock).trim();
        return result;
      }

      function replacePrefix(str, prefix, replacement) {
        if (str.toLowerCase().startsWith(prefix.toLowerCase())) {
          return replacement + str.slice(prefix.length);
        }
        return str;
      }

      function transformLine(line, opts) {
        let trimmed = line.trim();
        if (!trimmed.startsWith("[")) return line;
        let inner = trimmed.substring(1, trimmed.length - 1);
        let blocks = inner.split("] [");
        let marker = blocks[0];
        let isWinner = (marker.toLowerCase().includes("win") || marker.indexOf("+") !== -1);
        if (isWinner) {
          if (opts.shortenMarkers) {
            if (marker.toLowerCase().startsWith("win!")) {
              blocks[0] = replacePrefix(marker, "win!", "+");
            }
          }
        } else {
          if (opts.shortenMarkers && marker.toLowerCase().startsWith("lose")) {
            blocks[0] = replacePrefix(marker, "lose", "-");
          }
        }
        if ((isWinner && !opts.showWinningSideName) || (!isWinner && !opts.showLosingSideName)) {
          blocks[1] = "";
        }
        if ((isWinner && !opts.showWinningHP) || (!isWinner && !opts.showLosingHP)) {
          blocks[2] = "";
        }
        if ((isWinner && !opts.showWinningPercent) || (!isWinner && !opts.showLosingPercent)) {
          blocks[3] = "";
        }
        if ((isWinner && !opts.showWinningFaction) || (!isWinner && !opts.showLosingFaction)) {
          blocks[4] = "";
        }
        let heroBlockExists = false;
        let heroIdx = 5;
        if (blocks.length > heroIdx && blocks[heroIdx].includes("Уровень:")) {
          heroBlockExists = true;
          blocks[heroIdx] = transformHeroBlock(blocks[heroIdx], isWinner, opts);
        }
        let armyIdx = heroBlockExists ? 6 : 5;
        if (blocks.length > armyIdx) {
          if ((isWinner && !opts.showWinningArmy) || (!isWinner && !opts.showLosingArmy)) {
            blocks[armyIdx] = "";
          }
        }
        let bonusIdx = heroBlockExists ? 7 : 6;
        if (blocks.length > bonusIdx) {
          if ((isWinner && !opts.showWinningBonuses) || (!isWinner && !opts.showLosingBonuses)) {
            blocks[bonusIdx] = "";
          }
        }
        let newLine = blocks.filter(b => b !== "").map(b => "[" + b + "]").join(" ");
        return newLine;
      }

      function transformTokensText(inputText, opts) {
        let lines = inputText.split("\n");
        let transformed = lines.map(line => transformLine(line, opts));
        return transformed.join("\n");
      }

      /* Вспомогательная функция для вычисления градиентного цвета для заголовка уровня */
      function getLevelGradient(level) {
        // Уровень от 5 до 25 (всего 21 уровень)
        // При уровне 5: холодный (голубой ~hsl(240, 70%, 50%))
        // При уровне 25: жаркий (красный ~hsl(0, 70%, 50%))
        let clamped = Math.min(Math.max(level, 5), 25);
        let fraction = (clamped - 5) / 20;
        let hue = 240 - fraction * 240;  // линейно уменьшаем от 240 до 0
        // Создадим градиент от более тёмного к более светлому оттенку этого цвета
        return `linear-gradient(90deg, hsl(${hue}, 70%, 40%), hsl(${hue}, 70%, 60%))`;
      }
        
      // Функция для извлечения основного ключа и дополнительной информации из строки заголовка
        function parseGroupHeader(header) {
          // Предполагаем формат: "Основной текст (дополнительная часть)" – скобки необязательны
          // Используем регулярное выражение: основная часть – любой символ до первой открывающей скобки (если есть)
          // Дополнительная часть – всё, что внутри скобок
          const regex = /^(.*?)\s*(?:\((.+?)\))?$/;
          const match = header.match(regex);
          if (match) {
            return {
              main: match[1].trim(),
              extra: (match[2] || "").trim()
            };
          }
          return { main: header, extra: "" };
        }

        function compareGroupHeaders(a, b) {
          // Разбираем заголовки на основную и дополнительную части.
          let parsedA = parseGroupHeader(a);
          let parsedB = parseGroupHeader(b);

          // Сначала сравниваем основную часть (без учёта регистра)
          let mainCompare = parsedA.main.localeCompare(parsedB.main, undefined, { sensitivity: "base" });
          if (mainCompare !== 0) {
            return mainCompare;
          }
          
          // Если основные части равны, то пытаемся сравнить дополнительную, если она начинается с цифры.
          let regex = /^(\d+)/; // выдергиваем последовательность цифр в начале строки
          let matchA = parsedA.extra.match(regex);
          let matchB = parsedB.extra.match(regex);
          
          if (matchA && matchB) {
            let numA = parseInt(matchA[1], 10);
            let numB = parseInt(matchB[1], 10);
            if (numA !== numB) {
              return numA - numB; // возрастающий порядок: меньшие числа идут раньше
            }
            // Если числовые части равны, можно сравнить и остаток дополнительной информации
            return parsedA.extra.localeCompare(parsedB.extra, undefined, { sensitivity: "base" });
          }
          
          // Если хотя бы одна дополнительная часть не начинается с цифры, сравниваем их обычным лексикографически
          return parsedA.extra.localeCompare(parsedB.extra, undefined, { sensitivity: "base" });
        }


        // Функция для извлечения числового уровня из заголовка группы уровня
        function extractLevelNumber(levelHeader) {
          // Ожидается, что заголовок выглядит примерно так: "[Уровень: 18]"
          const regex = /\[Уровень:\s*(\d+)\]/i;
          const match = levelHeader.match(regex);
          return match ? parseInt(match[1], 10) : 0;
        }
        
      /* Функция отображения и группировки боёв */
      function displayBattles(battles) {
        const markers = markersInput.value.split(',')
                            .map(m => m.trim())
                            .filter(m => m);
        resultsContainer.innerHTML = '';
        let overallGroups = {};
        battles.forEach(battle => {
          let key = determineGroupKey(battle.result, markers);
          if (!overallGroups[key]) overallGroups[key] = [];
          overallGroups[key].push(battle);
        });
        // При сортировке общих групп можно выполнить следующее:
        let overallKeys = Object.keys(overallGroups);
        overallKeys.sort(compareGroupHeaders);
        overallKeys.forEach((overallKey) => {
        //for (let overallKey in overallGroups) {
          let overallDiv = document.createElement('div');
          overallDiv.className = 'result-group';
          let overallHeader = document.createElement('div');
          overallHeader.className = 'collapsible-group';
          overallHeader.textContent = overallKey;
          overallDiv.appendChild(overallHeader);
          let overallContent = document.createElement('div');
          overallContent.className = 'group-content';

          // Группировка по уровню победившей стороны
          let levelGroups = {};
          overallGroups[overallKey].forEach(battle => {
            // TO DO:
            let lvl = extractWinningLevel(battle.result, markers);
            if (!levelGroups[lvl]) levelGroups[lvl] = [];
            levelGroups[lvl].push(battle);
          });
          let levelKeys = Object.keys(levelGroups);
          levelKeys.sort((a, b) => {
            let numA = extractLevelNumber(a);
            let numB = extractLevelNumber(b);
            return numB - numA;
          });

          levelKeys.forEach(levelKey => {
            let battlesAtLevel = levelGroups[levelKey];
            let bestSurvival = Math.max(...battlesAtLevel.map(battle => extractSurvivalPercent(battle.result, markers)));
            let levelDiv = document.createElement('div');
            let levelHeader = document.createElement('div');
            levelHeader.className = 'collapsible-group';
            levelHeader.textContent = `${levelKey} [выжило ${bestSurvival.toFixed(2)}% у лучшего игрока]`;
            // Извлекаем числовое значение уровня из строки "[Уровень: N]"
            //let levelNum = parseInt(levelKey.replace(/\D/g, ''));
            let levelNum = extractLevelNumber(levelKey);
            // Применяем градиентный фон, вычисленный по уровню
            levelHeader.style.background = getLevelGradient(levelNum);
            levelHeader.style.color = '#fff';
            levelDiv.appendChild(levelHeader);
            let levelContent = document.createElement('div');
            levelContent.className = 'group-content';

            // Группировка по фракции
            let factionGroups = {};
            battlesAtLevel.forEach(battle => {
              let faction = extractFaction(battle.result);
              if (!factionGroups[faction]) factionGroups[faction] = [];
              factionGroups[faction].push(battle);
            });
            let factionKeys = Object.keys(factionGroups);
            factionKeys.sort((a, b) => {
              let bestA = Math.max(...factionGroups[a].map(battle => extractSurvivalPercent(battle.result, markers)));
              let bestB = Math.max(...factionGroups[b].map(battle => extractSurvivalPercent(battle.result, markers)));
              return bestB - bestA;
            });
            factionKeys.forEach(factionKey => {
              let best = Math.max(...factionGroups[factionKey].map(battle => extractSurvivalPercent(battle.result, markers)));
              let factionHeader = document.createElement('div');
              factionHeader.className = 'group-title';
              factionHeader.textContent = factionKey + " [выжило " + best.toFixed(2) + "% у лучшего игрока]";
              levelContent.appendChild(factionHeader);
              factionGroups[factionKey].sort((a, b) => {
                return extractSurvivalPercent(b.result, markers) - extractSurvivalPercent(a.result, markers);
              });
              factionGroups[factionKey].forEach(battle => {
                let battleDiv = document.createElement('div');
                battleDiv.className = 'battle';
                battleDiv.dataset.originalResult = battle.result;
                let linkDiv = document.createElement('div');
                linkDiv.className = 'battle-link';
                let linkA = document.createElement('a');
                linkA.href = battle.link;
                linkA.target = '_blank';
                linkA.textContent = battle.link;
                linkDiv.appendChild(linkA);
                battleDiv.appendChild(linkDiv);
                let resultDiv = document.createElement('div');
                resultDiv.className = 'battle-result';
                if (battle.result) {
                  battle.result.split('\n').forEach(line => {
                    let lineDiv = document.createElement('div');
                    lineDiv.className = 'result-line';
                    lineDiv.textContent = line;
                    if (line.startsWith('[win!]') || line.startsWith('[+]')) {
                      lineDiv.classList.add('win');
                    } else if (line.startsWith('[lose]') || line.startsWith('[-]')) {
                      lineDiv.classList.add('lose');
                    } else if (line.startsWith('[?]')) {
                      lineDiv.classList.add('unknown');
                    }
                    resultDiv.appendChild(lineDiv);
                  });
                }
                battleDiv.appendChild(resultDiv);
                levelContent.appendChild(battleDiv);
              });
            });
            levelDiv.appendChild(levelContent);
            overallContent.appendChild(levelDiv);

            levelHeader.addEventListener('click', function() {
              this.classList.toggle('active');
              let content = this.nextElementSibling;
              content.style.display = (content.style.display === 'block') ? 'none' : 'block';
            });
          });

          overallDiv.appendChild(overallContent);
          resultsContainer.appendChild(overallDiv);

          overallHeader.addEventListener('click', function() {
            this.classList.toggle('active');
            let content = this.nextElementSibling;
            content.style.display = (content.style.display === 'block') ? 'none' : 'block';
          });
        });
        updateFilteredOutput();
      }
      
      function handleEventChange() {
          currentEventId = Number(eventSelector.value);
          const ev = allEvents.find(e => e.eventId === currentEventId);

          // Обновляем весь контейнер
          eventSelectorHeader.textContent = `Выбран ивент: ${ev.title}`;
          eventAnnouncement.href    = ev.announcement || '#';
          eventAnnouncement.textContent = ev.announcement ? 'Перейти' : '—';
          eventReward.href          = ev.reward       || '#';
          eventReward.textContent   = ev.reward ? 'Перейти' : '—';
          eventMarkersDisplay.textContent = ev.eventMarkers;
          markersInput.value = ev.eventMarkers;

          // Фильтруем примеры
          const examplesFor = allExamples.filter(x => x.eventId === currentEventId);
          statusText.textContent = `Событие ${currentEventId}: ${examplesFor.length} боёв`;
          displayBattles(examplesFor);
          updateFilteredOutput();
        }

      
      function determineGroupKey(result, eventMarkers) {
        if (!result) return 'Без группы';
        const lines = result.split('\n').map(l => l.trim()).filter(l => l.length > 0);
        for (const line of lines) {
          let blocks = [];
          const regex = /\[([^\]]+)\]/g;
          let match;
          while ((match = regex.exec(line)) !== null) {
            blocks.push(match[1].trim());
          }
          if (!blocks.length) continue;
          for (let i = 0; i < blocks.length; i++) {
            for (const marker of eventMarkers) {
              if (blocks[i].toLowerCase().startsWith(marker.toLowerCase())) {
                const remainder = blocks[i].substring(marker.length).trim();
                if (remainder && (remainder.startsWith('(') || remainder.startsWith('{'))) {
                  return blocks[i];
                } else {
                  if (i + 3 < blocks.length) {
                    return marker + ": " + blocks[i + 3];
                  } else {
                    return marker;
                  }
                }
              }
            }
          }
        }
        return 'Без группы';
      }

      /* Обработчик сворачивания фильтра */
      const filterToggle = document.getElementById("filterToggle");
      const filterContent = document.getElementById("filterContent");
      const filterToggleIcon = document.getElementById("filterToggleIcon");

      /* Автоматическая загрузка ивентов и примеров при старте */
        try {
          statusText.textContent = 'Загружаем ивенты и примеры...';
          const t0 = performance.now();

          const res = await fetch('/.netlify/functions/getBattles');
          if (!res.ok) throw new Error('Ошибка загрузки данных');

          const data = await res.json();
          // Ожидаем { events: [...], examples: [...] }
          allEvents   = data.events   || [];
          allExamples = data.examples || [];

          // Очистить селектор на всякий случай
          eventSelector.innerHTML = '';

          // Наполняем селектор
          allEvents
            .sort((a,b) => a.eventId - b.eventId)
            .forEach(ev => {
              const opt = document.createElement('option');
              opt.value = ev.eventId;
              opt.text  = `${ev.eventId}: ${ev.title}`;
              eventSelector.appendChild(opt);
            });

          // Берём максимальный eventId и сразу рендерим
          currentEventId      = Math.max(...allEvents.map(e=>e.eventId));
          eventSelector.value = currentEventId;

          // Заполняем шапку и содержимое контейнера выбора ивента
          const chosen = allEvents.find(e => e.eventId === currentEventId);
          eventSelectorHeader.textContent  = `Выбран ивент: ${chosen.title}`;
          eventAnnouncement.href           = chosen.announcement || '#';
          eventAnnouncement.textContent    = chosen.announcement ? 'Перейти' : '—';
          eventReward.href                 = chosen.reward || '#';
          eventReward.textContent          = chosen.reward ? 'Перейти' : '—';
          eventMarkersDisplay.textContent  = chosen.eventMarkers;
          markersInput.value               = chosen.eventMarkers;

          // привязываем слушатель на изменение выбора в селекторе
          eventSelector.addEventListener('change', handleEventChange);

          // Первый рендер примеров
          handleEventChange();

          const t1 = ((performance.now() - t0)/1000).toFixed(2);
          statusText.textContent = `Данные загружены за ${t1}s — ивентов: ${allEvents.length}, примеров: ${allExamples.length}`;
        } catch (e) {
          console.error('Ошибка начальной загрузки:', e);
          statusText.textContent = 'Ошибка загрузки данных';
        }
    });
    function showInstructionModal() {
      let overlay = document.createElement('div');
      overlay.id = 'instructionOverlay';

      let modal = document.createElement('div');
      modal.id = 'instructionModal';
      // Здесь вставляем ваш полный текст инструкции. Он большой, поэтому используем многострочную строку.
      modal.innerHTML = `
        <h2>Инструкция по использованию сайта</h2>
        <p>
          <strong>Просмотр боёв</strong><br>
          Когда вы заходите на сервер, он обращается к базе данных и загружает оттуда уже имеющиеся бои. У меня это занимает 3 секунды. Загруженные бои группируются по противникам в порядке возрастания номеров волн. Для каждой волны бои группируются по боевым уровням героев в порядке их убывания. Список уровней имеет разнообразные цвета: высокоуровневые герои ближе к красному, низкоуровневые ближе к синему.<br><br>

          <strong>Фильтр информации о боях</strong><br>
          Об одном конкретном бое отображается очень много информации: кто сражался, сколько было ХП у его армии, сколько % выжило, кто был в его армии, какая фракция, что он получил за бой, какие статы были у героя, и т.д.. В будущем планирую добавить, какие артефакты носил герой, какие навыки у него были и какое умение фракции и анти-умение фракции, но сейчас этого нет.<br><br>

          Если вы считаете информацию избыточной, то используйте фильтры: отметьте галочками то, что хотите видеть. При изменении фильтра все описания боёв сразу же редактируются «налету», поэтому такая кнопка, как «применить фильтры» отсутствует. Выбранные фильтры сохраняются в браузере.<br><br>

          <strong>Отправка боёв</strong><br>
          Вы можете отправлять что угодно: текст, содержащий ссылки на бои, или HTML код страницы протокола боёв, содержащий бои. Всё, что содержит «war.php» или «warlog.php» будет считаться боем. Даже если www.heroeswm.ru или lordswm.com отсутствует (вы могли столкнуться с этим, когда открываете почту героев на телефоне), ссылки на бои будут корректно изъяты, а соответствующие www.heroeswm.ru добавлены автоматически.<br><br>

          Сервис автоматически проверит, что бой является боем ивента, который он хочет получить. Информация о том, что он хочет получить, указана в поле под вводом текста. Сейчас сервис принимает только «Цель контракта». Анализ боёв происходит на русском языке и если ссылка на бой ведёт на lordswm.com, то произойдет автоматическая замена на www.heroeswm.ru, поэтому, если вы англоговорящий, то вам ничего не требуется делать дополнительно: просто отправьте свои бои и всё (как отдельные ссылки или как HTML код страницы протокола боёв).<br><br>

          Сочетания клавиш для копирования и вставки HTML кода страницы на компьютере: на странице протокола боёв Ctrl+U, Ctrl+A, Ctrl+C, переход в поле ввода, Ctrl+V.<br><br>

          Дубликаты боёв будут автоматически удалены. Проверяется не ссылка, а параметр «warid»: две ссылки с одним и тем же «warid» считаются одинаковыми.<br><br>

          На мобильном телефоне тоже работает: я проверял на Mozilla Firefox Mobile. Но я установил расширение «View Page Source» из магазина расширений Firefox.<br><br>

          Отправка боёв занимает несколько секунд. Не закрывайте вкладку сразу: дождитесь сообщения, что всё готово.<br><br>

          <strong>Другие ивенты</strong><br>
          Пока что первоначальная настройка нового ивента работает вручную. Я должен сбрасывать базу данных и выставлять маркеры боёв ивента (например, «Цель контракта») в начале каждого нового ивента. Но на ивентах, где нет номеров волн, уже сейчас враги группируются не по номерам волн, а по фракциям соперников. Например, «Враги: Механики», или «Враги: Разбойники» вместо «Цель контракта (10-1)» и «Цель контракта (40-2)».
        </p>
        <div style="text-align: center; margin-top: 20px;">
          <button class="instruction-btn ok" id="instructionOk">Понял</button>
          <button class="instruction-btn noShow" id="instructionNoShow">Больше не показывать</button>
        </div>
      `;
      overlay.appendChild(modal);
      document.body.appendChild(overlay);

      document.getElementById('instructionOk').addEventListener('click', () => {
        document.body.removeChild(overlay);
      });
      document.getElementById('instructionNoShow').addEventListener('click', () => {
        localStorage.setItem('dontShowInstructions', 'true');
        document.body.removeChild(overlay);
      });
    }

    function checkAndShowInstructions() {
      if (!localStorage.getItem('dontShowInstructions')) {
        showInstructionModal();
      }
    }

    // Добавляем обработчик для кнопки инструкции в статус-баре
    document.addEventListener('DOMContentLoaded', () => {
      checkAndShowInstructions();
      const instructionToggleBtn = document.getElementById('instructionToggleBtn');
      instructionToggleBtn.addEventListener('click', showInstructionModal);
    });
    
    document.querySelectorAll('.collapsible, .filter-header').forEach(btn=>{
      const body = btn.nextElementSibling;
      btn.addEventListener('click', ()=>{
        btn.classList.toggle('active');

        // для обычных блоков – display, для фильтра – класс
        if (btn.id === 'filterToggle') {
          body.classList.toggle('collapsed');
          filterToggleIcon.innerHTML = body.classList.contains('collapsed') ? '&#9654;' : '&#9660;';
        } else {
          body.style.display = body.style.display==='block' ? 'none' : 'block';
        }

        setTimeout(recalcStickyOffsets, 0);
      });
    });
    btn.addEventListener('click', () => {
      btn.classList.toggle('active');

      if (btn.id === 'filterToggle') {
        body.classList.toggle('collapsed');
        filterToggleIcon.innerHTML = body.classList.contains('collapsed') ? '►' : '▼';
      } else {
        const opened = body.style.display !== 'block';
        body.style.display = opened ? 'block' : 'none';

        /* если мы ТОЛЬКО‑ЧТО раскрыли — прокручиваем к началу тела */
        if (opened) body.scrollIntoView({ behavior:'smooth', block:'start' });
      }

      setTimeout(recalcStickyOffsets, 0);
    });
  </script>
</body>
</html>
