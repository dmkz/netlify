<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Анализ боёв</title>
  <style>
    /* Общие стили */
    body {
      font-family: Arial, sans-serif;
      background: #f2f2f2;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 960px;
      margin: auto;
      padding: 20px;
    }
    
    /* Стили для первой сворачиваемой секции "Отправка боёв" */
    .collapsible {
      background-color: #333;
      color: #fff;
      cursor: pointer;
      padding: 18px;
      width: 100%;
      border: none;
      text-align: left;
      outline: none;
      font-size: 20px;
      border-radius: 4px;
      margin-bottom: 10px;
      position: relative;
    }
    .collapsible::after {
      content: "\25B6"; /* стрелка вправо */
      position: absolute;
      right: 20px;
      font-size: 20px;
    }
    .collapsible.active::after {
      content: "\25BC"; /* стрелка вниз */
    }
    .content {
      padding: 0 18px;
      display: none;
      overflow: hidden;
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-bottom: 20px;
    }
    textarea {
      width: 100%;
      height: 150px;
      font-size: 16px;
      padding: 10px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    input[type="text"] {
      width: calc(100% - 20px);
      padding: 10px;
      font-size: 16px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 10px;
    }
    button.send {
      background-color: #28a745;
      color: #fff;
    }
    button.clear {
      background-color: #dc3545;
      color: #fff;
    }
    .status-bar {
      margin-top: 10px;
      font-size: 16px;
    }
    
    /* Стили для группировки боёв */
    .result-group {
      border: 1px solid #ccc;
      background: #fff;
      border-radius: 4px;
      margin-bottom: 20px;
      overflow: hidden;
    }
    /* Заголовок группировки – сворачиваемый блок */
    .collapsible-group {
      background-color: #e0e0e0; /* серый фон */
      cursor: pointer;
      padding: 10px;
      font-size: 18px;
      font-weight: bold;
      border-bottom: 1px solid #ccc;
      position: relative;
    }
    .collapsible-group::after {
      content: "\25B6"; /* стрелка вправо */
      position: absolute;
      right: 10px;
      font-size: 18px;
    }
    .collapsible-group.active::after {
      content: "\25BC"; /* стрелка вниз */
    }
    .group-content {
      display: none;
      padding: 10px;
    }
    
    /* Стили для боёв */
    .battle {
      border-bottom: 1px dashed #ccc;
      padding: 10px 0;
    }
    .battle:last-child {
      border-bottom: none;
    }
    .battle-link a {
      color: #007bff;
      text-decoration: none;
    }
    .battle-link a:hover {
      text-decoration: underline;
    }
    
    /* Фоны для строк анализа */
    .result-line {
      padding: 5px;
      border-radius: 4px;
      margin-bottom: 3px;
    }
    /* Если строка начинается с [win!] или [+] - легкий зелёный фон */
    .result-line.win {
      background-color: #d4edda;
    }
    /* Если строка начинается с [lose] или [-] - легкий красный фон */
    .result-line.lose {
      background-color: #f8d7da;
    }
    /* Если строка начинается с [?] - легкий жёлтый фон */
    .result-line.unknown {
      background-color: #fff3cd;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Блок отправки боёв -->
    <button type="button" class="collapsible">Отправка боёв</button>
    <div class="content">
      <textarea id="battleInput" placeholder="Вставьте сюда текст с боями..."></textarea>
      <input type="text" id="markersInput" placeholder="Маркеры ивента (через запятую)">
      <div>
        <button class="send" id="sendButton">Отправить</button>
        <button class="clear" id="clearButton">Очистить</button>
      </div>
      <div class="status-bar" id="statusBar">Статус: ожидаем ввода</div>
    </div>
    
    <!-- Контейнер для отображения результатов -->
    <div id="resultsContainer"></div>
  </div>
  
  <script>
    // Элементы страницы
    const collapsible = document.querySelector('.collapsible');
    const content = document.querySelector('.content');
    const battleInput = document.getElementById('battleInput');
    const markersInput = document.getElementById('markersInput');
    const sendButton = document.getElementById('sendButton');
    const clearButton = document.getElementById('clearButton');
    const statusBar = document.getElementById('statusBar');
    const resultsContainer = document.getElementById('resultsContainer');
    
    // Сворачивание/разворачивание блока "Отправка боёв"
    collapsible.addEventListener('click', function() {
      this.classList.toggle("active");
      content.style.display = (content.style.display === "block") ? "none" : "block";
    });
    
    // Очистка поля ввода
    clearButton.addEventListener('click', function() {
      battleInput.value = '';
      statusBar.textContent = 'Статус: очищено';
    });
    
    // Обработка нажатия на кнопку «Отправить»
    sendButton.addEventListener('click', async function() {
      statusBar.textContent = 'Статус: обработка ввода...';
      const inputText = battleInput.value;
      if (!inputText.trim()) {
        statusBar.textContent = 'Статус: пустой ввод';
        return;
      }
      
      let battleLinks = extractBattleLinks(inputText);
      if (battleLinks.length === 0) {
        statusBar.textContent = 'Статус: не найдено ссылок на бои';
        return;
      }
      
      let battles = battleLinks.map(link => {
        const normalized = normalizeBattleLink(link);
        const warid = extractWarId(normalized);
        return { warid, link: normalized, result: null };
      }).filter(b => b.warid);
      
      let storedBattles = JSON.parse(localStorage.getItem('battles') || '[]');
      let battlesMap = {};
      storedBattles.forEach(b => { battlesMap[b.warid] = b; });
      battles.forEach(b => {
        if (!battlesMap[b.warid]) battlesMap[b.warid] = b;
      });
      let allBattles = Object.values(battlesMap);
      
      statusBar.textContent = `Статус: ${allBattles.length} боёв, ожидание анализа...`;
      
      allBattles = await analyzeBattles(allBattles);
      
      // Фильтрация по маркерам
      const markers = markersInput.value.split(',').map(m => m.trim()).filter(m => m);
      if (markers.length > 0) {
        allBattles = allBattles.filter(b => battleHasMarkers(b.result, markers));
      }
      
      localStorage.setItem('battles', JSON.stringify(allBattles));
      
      displayBattles(allBattles);
      statusBar.textContent = `Статус: обработка завершена. Всего боёв: ${allBattles.length}`;
    });
    
    // Функция для извлечения ссылок с war.php или warlog.php
    function extractBattleLinks(text) {
      const regex = /(?:https?:\/\/[^\s'"]+)?\/?(war(?:log)?\.php\?[^"'\s]+)/gi;
      let links = [];
      let match;
      while ((match = regex.exec(text)) !== null) {
        links.push(match[1]);
      }
      return links;
    }
    
    // Нормализация ссылки
    function normalizeBattleLink(link) {
      if (!link.startsWith('http')) {
        link = 'https://www.heroeswm.ru/' + link;
      } else {
        link = link.replace(/https?:\/\/(www\.heroeswm\.ru|mirror\.heroeswm\.ru|my\.lordswm\.com|www\.lordswm\.com|lordswm\.com)/i, 'https://www.heroeswm.ru');
      }
      link = link.replace(/warlog\.php/gi, 'war.php');
      try {
        let url = new URL(link);
        url.searchParams.delete('lt');
        return url.toString();
      } catch (e) {
        console.error('Ошибка нормализации ссылки:', link, e);
        return link;
      }
    }
    
    // Извлечение параметра warid
    function extractWarId(link) {
      try {
        let url = new URL(link);
        return url.searchParams.get('warid');
      } catch (e) {
        console.error('Ошибка извлечения warid из ссылки:', link, e);
        return null;
      }
    }
    
    // Функция анализа боёв (упрощённая схема)
    async function analyzeBattles(battles) {
      let pendingBattles = battles.filter(b => !b.result);
      let attempt = 1;
      while (pendingBattles.length > 0) {
        statusBar.textContent = `Анализируем: ${pendingBattles.length} боёв. Попытка ${attempt}...`;
        const startTime = performance.now();
        try {
          let response = await fetch('https://hwm-nightly.netlify.app/netlify/functions/analyzeBattles', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ links: pendingBattles.map(b => b.link) })
          });
          let data = await response.json();
          data.results.forEach(res => {
            let b = battles.find(battle => battle.link === res.link);
            if (b) {
              if (res.status === 'success' && res.result) {
                b.result = res.result;
              } else {
                b.result = null;
              }
            }
          });
        } catch (e) {
          console.error('Ошибка при запросе анализа:', e);
        }
        const elapsed = ((performance.now() - startTime) / 1000).toFixed(3);
        let successCount = battles.filter(b => b.result).length;
        let errorCount = battles.filter(b => !b.result).length;
        statusBar.textContent = `Анализ: ${battles.length} боёв. Успех: ${successCount}. Ошибка: ${errorCount}. Время: ${elapsed} с. Попытка ${attempt}`;
        pendingBattles = battles.filter(b => !b.result);
        if (pendingBattles.length > 0) {
          await new Promise(r => setTimeout(r, 1000));
          attempt++;
        }
      }
      return battles;
    }
    
    // Проверка наличия маркера в результате
    function battleHasMarkers(result, markers) {
      if (!result) return false;
      return markers.some(marker => {
        const regex = new RegExp('\\[' + marker + '(\\s*[({]|\\])', 'i');
        return regex.test(result);
      });
    }
    
    /**
     * Функция определяет заголовок для группировки боёв.
     * Проходит по строкам результата, ищет блок(и) с указанными маркерами ивента.
     * Если дополнительная информация (в круглых или фигурных скобках) присутствует сразу после маркера,
     * то берётся этот блок. Иначе берётся блок, который на 3 позиции правее маркера – он содержит фракцию.
     */
    function determineGroupKey(result, eventMarkers) {
      if (!result) return 'Без группы';
      const lines = result.split('\n').map(l => l.trim()).filter(l => l.length > 0);
      for (const line of lines) {
        let blocks = [];
        const regex = /\[([^\]]+)\]/g;
        let match;
        while ((match = regex.exec(line)) !== null) {
          blocks.push(match[1].trim());
        }
        if (!blocks.length) continue;
        for (let i = 0; i < blocks.length; i++) {
          for (const marker of eventMarkers) {
            if (blocks[i].toLowerCase().startsWith(marker.toLowerCase())) {
              const remainder = blocks[i].substring(marker.length).trim();
              if (remainder && (remainder.startsWith('(') || remainder.startsWith('{'))) {
                return blocks[i];
              } else {
                if (i + 3 < blocks.length) {
                  return marker + ": " + blocks[i + 3];
                } else {
                  return marker;
                }
              }
            }
          }
        }
      }
      return 'Без группы';
    }
    
    // Функция отображения боёв с группировкой и сворачиваемыми группами
    function displayBattles(battles) {
      // Получаем маркеры из поля ввода
      const markers = markersInput.value.split(',')
                          .map(m => m.trim())
                          .filter(m => m);
      resultsContainer.innerHTML = '';
      let groups = {};
      battles.forEach(battle => {
        let groupKey = determineGroupKey(battle.result, markers);
        if (!groups[groupKey]) groups[groupKey] = [];
        groups[groupKey].push(battle);
      });
      for (let key in groups) {
        // Создаем обёртку для группы
        let groupDiv = document.createElement('div');
        groupDiv.className = 'result-group';
        
        // Заголовок группы, сворачиваемый
        let header = document.createElement('div');
        header.className = 'collapsible-group';
        header.textContent = key;
        groupDiv.appendChild(header);
        
        // Контейнер с содержимым группы – изначально скрыт
        let groupContent = document.createElement('div');
        groupContent.className = 'group-content';
        
        groups[key].forEach(battle => {
          let battleDiv = document.createElement('div');
          battleDiv.className = 'battle';
          
          let linkDiv = document.createElement('div');
          linkDiv.className = 'battle-link';
          let linkA = document.createElement('a');
          linkA.href = battle.link;
          linkA.target = '_blank';
          linkA.textContent = battle.link;
          linkDiv.appendChild(linkA);
          battleDiv.appendChild(linkDiv);
          
          let resultDiv = document.createElement('div');
          resultDiv.className = 'battle-result';
          if (battle.result) {
            battle.result.split('\n').forEach(line => {
              let lineDiv = document.createElement('div');
              lineDiv.className = 'result-line';
              lineDiv.textContent = line;
              // Присвоение фона в зависимости от начальных блоков
              if (line.startsWith('[win!]') || line.startsWith('[+]')) {
                lineDiv.classList.add('win');
              } else if (line.startsWith('[lose]') || line.startsWith('[-]')) {
                lineDiv.classList.add('lose');
              } else if (line.startsWith('[?]')) {
                lineDiv.classList.add('unknown');
              }
              resultDiv.appendChild(lineDiv);
            });
          }
          battleDiv.appendChild(resultDiv);
          groupContent.appendChild(battleDiv);
        });
        groupDiv.appendChild(groupContent);
        resultsContainer.appendChild(groupDiv);
      }
      
      // Добавляем обработчики для сворачивания/разворачивания групп
      const groupHeaders = document.querySelectorAll('.collapsible-group');
      groupHeaders.forEach(header => {
        header.addEventListener('click', function() {
          this.classList.toggle('active');
          const content = this.nextElementSibling;
          content.style.display = (content.style.display === 'block') ? 'none' : 'block';
        });
      });
    }
  </script>
</body>
</html>
